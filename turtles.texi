\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename turtles.info
@documentencoding UTF-8
@ifinfo
@*Generated by Sphinx.@*
@end ifinfo
@settitle Visual Replace
@defindex ge
@paragraphindent 0
@exampleindent 4
@finalout
@dircategory Emacs
@direntry
* turtles: (turtles.info). Library for writing ERT-based tests that check how
                        Emacs renders buffers and windows.
@end direntry

@c %**end of header

@copying
@quotation
Turtles

Stephane Zermatten

Copyright @copyright{} 2024, Stephane Zermatten
@end quotation

@end copying

@titlepage
@title Visual Replace
@insertcopying
@end titlepage
@contents

@c %** start of user preamble

@c %** end of user preamble

@ifnottex
@node Top
@top Visual Replace
@insertcopying
@end ifnottex

@c %**start of body
@anchor{index doc}@anchor{0}
Turtles is an Emacs elisp package that helps write ERT-based tests
that check how Emacs renders buffers and windows. The ERT tests can be
run interactively or in batch mode. You’ll find the source code of
this package on @indicateurl{https://github.com/szermatt/turtles}

Go to @ref{1,,Tutorial} to get started.

Turtles is especially suited to test:


@itemize -

@item 
the effect of display, before-string, after-string text properties

@item 
the effect of overlays

@item 
text visibility

@item 
mode lines

@item 
complex minibuffer interactions
@end itemize

`This program is free software: you can redistribute it and/or
modify it under the terms of the GNU General Public License as
published by the Free Software Foundation; either version 3 of the
License, or (at your option) any later version.'

`This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.'

`You should have received a copy of the GNU General Public License
along with this program.  If not, see' @indicateurl{http://www.gnu.org/licenses/}

@menu
* Contents:: 
* Index:: 

@detailmenu
 --- The Detailed Node Listing ---

Contents

* Installation:: 
* Tutorial:: 
* Reference:: 
* Contributing:: 

Tutorial

* Screen Grabbing:: 
* Minibuffer:: 
* Faces with Isearch:: 

Reference

* ERT Integration:: 
* Screen Grab:: 
* Minibuffer: Minibuffer<2>. 
* Instance Management:: 
* Visiting Instance Buffers:: 
* RPC (turtles-io): RPC turtles-io. 

Contributing

* Reporting issues:: 
* Suggesting features:: 
* Asking questions:: 
* Code contributions:: 
* Documentation contributions:: 

@end detailmenu
@end menu

@node Contents,Index,Top,Top
@anchor{index contents}@anchor{2}@anchor{index turtles}@anchor{3}
@chapter Contents


@menu
* Installation:: 
* Tutorial:: 
* Reference:: 
* Contributing:: 

@end menu

@node Installation,Tutorial,,Contents
@anchor{install doc}@anchor{4}@anchor{install install}@anchor{5}@anchor{install installation}@anchor{6}
@section Installation


Install Turtles:


@itemize -

@item 
on a recent version of Emacs (29 or later), from the
github repository by doing @code{M-x package-vc-install
https://github.com/szermatt/turtles}

@item 
from source, using an alternative package managers, such as straight@footnote{https://github.com/radian-software/straight.el}, shown here:

@example
(use-package turtles
  :straight (:type git :repo "https://github.com/szermatt/turtles.git"))
@end example

@item 
the old-fashioned way, copying the .el files from into your
@code{.emacs.d} directory.

@item 
using eldev@footnote{https://github.com/emacs-eldev/eldev} to run tests in batch mode:

@example
(eldev-add-extra-dependencies 'test 'turtles)
(eldev-use-vc-repository 'turtles :github "szermatt/turtles")
@end example
@end itemize

Turtles requires Emacs 26.1 or later. Emacs 29.1 or later is recommended.

@node Tutorial,Reference,Installation,Contents
@anchor{tutorial doc}@anchor{7}@anchor{tutorial tut}@anchor{1}@anchor{tutorial tutorial}@anchor{8}
@section Tutorial


Turtles is a collection of tools for writing ERT tests that look at
the terminal showing an interactive Emacs instance from within that
instance. That is, you can setup buffer content and windows and check
how it looks like to a user running Emacs in a terminal.

Such ERT tests can run in batch mode as well an in interactive mode,
together with normal ERT tests.

To make that work, Turtles starts a secondary Emacs instance from
within a terminal buffer. Tests run in the secondary Emacs instance
and their result communicated to the primary Emacs instance. Whenever
needed, the primary instance grab the screen and provides the result,
that is, a terminal screen with colors and cursor position, to the
secondary instance.

To get started, @ref{5,,install turtles}, create a new ERT
test file with:

@example
;; -*- lexical-binding: t -*-

(require 'ert)
(require 'ert-x)
(require 'turtles)
@end example

If you checked out the source from
@indicateurl{https://github.com/szermatt/turtles}, you’ll find the tests shown
in this tutorial in the file test/turtles-example-test.el@footnote{https://github.com/szermatt/turtles/blob/master/test/turtles-examples-test.el}
and you can run them interactively or in batch mode using @code{eldev
test}.

@menu
* Screen Grabbing:: 
* Minibuffer:: 
* Faces with Isearch:: 

@end menu

@node Screen Grabbing,Minibuffer,,Tutorial
@anchor{tutorial screen-grabbing}@anchor{9}@anchor{tutorial tut-hello-world}@anchor{a}
@subsection Screen Grabbing


To get started, let’s create a test that creates a buffer, renders it
and check the result:

@example
(ert-deftest turtles-examples-hello-world ()
   ;; Start a secondary Emacs instance
  (turtles-ert-test)

  ;; From this point, everything runs in the secondary instance.
  (ert-with-test-buffer ()
    (insert "hello, ") ; Fill in the buffer
    (insert (propertize "the " 'invisible t))
    (insert "world!\n")

    (turtles-with-grab-buffer () ; Grab current buffer content
      (should (equal "hello, world!"
                     (buffer-string))))))
@end example

The first call in the test is @ref{b,,(turtles-ert-test)}. This
function creates a secondary Emacs instances, then runs the rest of
the test within that instance.

What Turtles calls instance is a separate Emacs process that
@code{turtles-ert-test} started within a terminal window.

Running within a secondary instance is only useful because it is
needed by @ref{c,,(turtles-with-grab-buffer)}. This macro
displays its containing buffer in a window, grabs the content of that
window and puts than into an ERT test buffer.

The body of @code{turtles-with-grab-buffer} runs within that grabbed
buffer, just like the body of @code{ert-with-test-buffer}. Its content
can be modified and checked with the usual tools.

Obviously, the window that was grabbed didn’t have just two lines and
was larger than just the two words that appear here. What was really
grabbed contained spaces and newlines that
@code{turtles-with-grabbed} trimmed automatically to make it easier
to test.

Try passing the option @code{:trim t} and running the test with
@code{ert-run-tests-interactively}:

@example
(turtles-with-grab-buffer (:trim t)
  (should (equal "hello, world!"
                 (buffer-string))))))
@end example

You’ll then see something like the following:

@example
F turtles-examples-hello-world
    Buffer: *Test buffer (turtles-examples-hello-world)*
    Buffer: *Test buffer (turtles-examples-hello-world): grab*
    (ert-test-failed
     ((should
       (equal "hello, world!"
              (buffer-string)))
      :form
      (equal "hello, world!"
             #("hello, world!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n" 0 13
               (face
                (...))
               13 35
               (face default)))
      :value nil :explanation
      (arrays-of-different-length 13 35 "hello, world!"
                                  #("hello, world!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n" 0 13
                                    (face
                                     (...))
                                    13 35
                                    (face default))
                                  first-mismatch-at 13)))
@end example

As you can see above, the window that was grabbed had a bit more than
20 lines. This corresponds to a single window within a 80x24, the size
of the default @ref{d,,instance}.

The ERT test buffers listed above

@example
Buffer: *Test buffer (turtles-examples-hello-world)*
Buffer: *Test buffer (turtles-examples-hello-world): grab*
@end example

are part of that instance. If you click on either one of these, you’ll
be offered a choice of different ways of seeing these buffers. The
most convenient one, if you’re running in a windowing environment, is
to ask the instance to create a new frame to show the buffer.

@code{turtles-with-grab-buffer} doesn’t just grab the window content,
of course, but actually the whole frame, then strips out everything
that’s outside the window. To better understand what this means, add
the option @code{frame t}, as shown below, and run the tests again:

@example
(turtles-with-grab-buffer (:frame t)
  (should (equal "hello, world!"
                 (buffer-string))))))
@end example

They will fail, and in the error message, or the buffers listed there,
you’ll see the entire Emacs frame that was grabbed, including the mode
line and message area.

Have a look at the @ref{c,,turtles-with-grab-buffer reference} to
see how you can grab other sections of the screen.

@node Minibuffer,Faces with Isearch,Screen Grabbing,Tutorial
@anchor{tutorial minibuffer}@anchor{e}@anchor{tutorial tut-minibuffer}@anchor{f}
@subsection Minibuffer


This second example illustrates the use of
@ref{10,,(turtles-with-minibuffer)} running
@code{completing-read}:

@example
(ert-deftest turtles-examples-test-completing-read ()
  (turtles-ert-test)

  (ert-with-test-buffer ()
    (let ((completing-read-function #'completing-read-default))
      (turtles-with-minibuffer
          (should
           (equal "Choice B"
                  (completing-read "Choose: " '("Choice A" "Choice B") nil t)))

        (turtles-with-grab-buffer (:name "initial prompt" :point "<>")
          (should (equal "Choose: <>" (buffer-string))))

        :keys "Ch TAB"
        (turtles-with-grab-buffer (:name "completion" :point "<>")
          (should (equal "Choose: Choice <>" (buffer-string))))

        :keys "B"))))
@end example

@code{turtles-with-minibuffer} takes as argument two separate sections, as shown below:

@example
(turtles-with-minibuffer
    READ
  BODY)
@end example

The READ section is a single sexp that calls a function that runs on
the minibuffer or within a recursive-edit. When this function returns,
@code{turtles-with-minibuffer} ends and returns the result of
evaluating READ.

The example above doesn’t care about what READ evaluates to, because
it checks the retrun value of @code{completing-read} directly within
that section.

The BODY section is a series of sexp that is executed interactively
`while the READ section runs'. This isn’t multi-threading;
@code{turtles-with-minibuffer} waits for the READ sections to call
@code{recursive-edit}, usually indirectly through
@code{read-from-minibuffer}, and runs BODY within that interactive
session.

At the end of BODY, the minibuffer is closed, if needed, and control
returns to READ, which checks the result of running BODY.

Within that example BODY first checks the minibuffer content with:

@example
(turtles-with-grab-buffer (:name "initial prompt" :point "<>")
  (should (equal "Choose: <>" (buffer-string))))
@end example

The argument :point tells @code{turtles-with-grab-buffer} to
highlight the position of the cursor with “<>”. You can also check
that manually; it’s just convenient to see the content and the
position of the point in the same string.

This test interacts with @code{completing-read} by simulating the
user typing some text and pressing @code{TAB}. It uses @ref{10,,;keys} for that, which instructs the macro
@code{turtles-with-minibuffer} to simulates the user typing some
keys.

The test could have called the command @code{TAB} corresponds to directly:

@example
:keys "Ch"
(minibuffer-complete)
(turtles-with-grab-buffer (:name "completion" :point "<>")
  (should (equal "Choose: Choice <>" (buffer-string))))
@end example

Calling interactive commands in such a way in a test is usually
clearer than going through key bindings, and in most cases, it works well.

Some commands that rely on the specific environment provided by the
command loop won’t work if called directly.
@ref{10,,;command} can help with such commands,
though it might be considered overkill here:

@example
:keys "Ch"
:command #'minibuffer-complete
(turtles-with-grab-buffer (:name "completion" :point "<>")
  (should (equal "Choose: Choice <>" (buffer-string))))
@end example

@node Faces with Isearch,,Minibuffer,Tutorial
@anchor{tutorial faces-with-isearch}@anchor{11}@anchor{tutorial tut-isearch}@anchor{12}
@subsection Faces with Isearch


This last example tests isearch. While not a minibuffer-based command,
isearch still works with @code{turtles-with-minibuffer}.

@example
(ert-deftest turtles-examples-test-isearch ()
  (turtles-ert-test)

  (ert-with-test-buffer ()
    (let ((testbuf (current-buffer)))
      (select-window (display-buffer testbuf))
      (delete-other-windows)

      (insert "Baa, baa, black sheep, have you any wool?")
      (goto-char (point-min))

      (turtles-with-minibuffer
          (isearch-forward)

        :keys "baa"
        (turtles-with-grab-buffer (:minibuffer t)
          (should (equal "I-search: baa" (buffer-string))))
        (turtles-with-grab-buffer (:buf testbuf :name "match 1" :faces '((isearch "[]")))
          (should (equal "[Baa], baa, black sheep, have you any wool?"
                         (buffer-string))))

        :keys "\C-s"
        (turtles-with-grab-buffer (:buf testbuf :name "match 2" :faces '((isearch "[]")))
          (should (equal "Baa, [baa], black sheep, have you any wool?"
                         (buffer-string))))

        (isearch-done))

      (turtles-with-grab-buffer (:name "final position" :point "<>")
        (should (equal "Baa, baa<>, black sheep, have you any wool?"
                       (buffer-string)))))))
@end example

The interesting bit here is:

@example
(turtles-with-grab-buffer (:buf testbuf :name "match 1" :faces '((isearch "[]")))
  (should (equal "[Baa], baa, black sheep, have you any wool?"
                 (buffer-string))))
@end example

This test is used to check which part of the buffer isearch
highlighted.

The argument :faces tells @code{turtles-with-grab-buffer} to grab a
small set of faces and make them available in the buffer as the text
property ‘face.

This example additionally asks @code{turtles-with-grab-buffer} to
detect portions of the buffer with such a face and surround them with
brackets, to make it more convenient to test.

Faces aren’t available in a terminal, of course. Turtles uses colors
to highlight the faces it’s interested in, then processes the grabbed
data to recognize the faces it wants from these colors it has
assigned.

@node Reference,Contributing,Tutorial,Contents
@anchor{reference doc}@anchor{13}@anchor{reference ref}@anchor{14}@anchor{reference reference}@anchor{15}
@section Reference


@menu
* ERT Integration:: 
* Screen Grab:: 
* Minibuffer: Minibuffer<2>. 
* Instance Management:: 
* Visiting Instance Buffers:: 
* RPC (turtles-io): RPC turtles-io. 

@end menu

@node ERT Integration,Screen Grab,,Reference
@anchor{reference ert}@anchor{b}@anchor{reference ert-integration}@anchor{16}
@subsection ERT Integration


@geindex function; turtles-ert-test
@geindex function; turtles-upstream
@geindex function; turtles-this-instance

Turtles runs ERT tests is a secondary Emacs instance, which is started
and piloted by Turtles. This is what allows everything else in this
section to work.


@table @asis

@item (turtles-ert-test &key instance timeout) : macro

This macro marks the current test as a Turtles test. It connects
to a secondary Emacs instance, starts it if necessary, then runs
everything below (turtles-ert-test) in that secondary instance.

The ID of the instance to connect can be passed to the key
argument :instance. That ID defaults to @code{default}, with a
80x24 terminal. See the @ref{d,,Instance Management} section for details on
how to define new instances.

A :timeout value, in seconds, can be passed to tell Turtles how
long to wait for an answer from the secondary instance. Increase
this value if you’re getting timeout errors.

@item (turtles-this-instance) : function

When run in a secondary Emacs instance, this function returns
the instance ID. It returns nil when not called from an
instance.

Calling this function provides a convenient way of knowing
whether the current code is running in the main Emacs process or
a secondary instance started by Turtles.

@item (turtles-upstream) : function

When called from a secondary Emacs instance, this function
returns the connection to the main Emacs process, a
@code{turtles-io-conn} struct, described in section @ref{17,,RPC (turtles-io)}.

When called from the main Emacs process, this function returns
nil.
@end table

@node Screen Grab,Minibuffer<2>,ERT Integration,Reference
@anchor{reference grab}@anchor{c}@anchor{reference screen-grab}@anchor{18}
@subsection Screen Grab


@geindex function; turtles-with-grab-buffer
@geindex function; turtles-to-string
@geindex function; turtles-mark-text-with-face
@geindex function; turtles-mark-text-with-faces
@geindex function; turtles-mark-point
@geindex function; turtles-trim-buffer
@geindex function; turtles-grab-frame
@geindex function; turtles-grab-buffer
@geindex function; turtles-grab-mode-line
@geindex function; turtles-grab-header-line
@geindex function; turtles-grab-window

Two macros are provided that fully control how the terminal frame is
grabbed and fully-processed: @code{turtles-with-grab-buffer} and
@code{turtles-to-string}:


@table @asis

@item (turtles-with-grab-buffer (&key …) &rest body) : macro

This macro creates an ERT test buffer, grab the specified
portion of the frame, post-processes it, then evaluates BODY.

BODY then usually checks the buffer content @code{should}.

Key arguments:

@quotation

`:name NAME' specifies the buffer name, “grab” by default. It is
forwarded to @code{ert-with-test-buffer}.
@end quotation

Key arguments that control what to grab:

@quotation

By default, the macro grabs the current buffer. If the buffer
is already shown in a window, it grabs that window, otherwise
it shows the buffer in a single window and grabs that.

:buf BUFFER-OR-NAME specifies another buffer to grab

:win WINDOW specifies a window to grab. The window doesn’t
have to be selected. However it will be selected when
grabbing.

:mode-line WIN-OR-BUF grabs the mode-line of the specified window or buffer.

:header-line WIN-OR-BUF grabs the header-line of the specified window or buffer.

:minibuffer t grabs the minibuffer window.

:margins t grabs the left and right margin. This only has an
effect when grabbing a buffer or a window.

:frame t grabs the whole frame.
@end quotation

Key arguments that control how to post-process what is grabbed:

@quotation

:point STR marks the position of the cursor with STR.

:faces FACE-LIST-OR-ALIST specifies a set of faces to grab. To
do that, Turtles assigns specific color to each face, grabs the
result, then detects faces in the gabbed data from colors. This
means that color data isn’t available when this option is used.

The face data can be recovered in the grabbed buffer in the text
property ‘face.

Additionally, it is possible to specify strings to use to mark
regions of the buffer with a specific face, to make it easier
to test using just (equals … (buffer-string)).

FACE-LIST-OR-ALIST is a list of either:


@itemize -

@item 
the face to grab, a symbol

@item 
( face pair ) with pair being a string that can be split into
opening and closing strings, for example “()”, “[]” or even “<<>>”.

@item 
( face opening closing ) opening being
opening and closing strings, for example “face1:(” “)”
@end itemize

:trim nil tells the macro not to remove trailing whitespaces
and newlines.
@end quotation

@item (turtles-to-string) : macro

This macro works just like @code{turtle-with-grab-buffer} and
takes the same arguments, described above. The only difference
is that instead of opening an ERT test buffer, this function
returns the buffer content as a string.

So, instead of:

@example
(turtles-with-grab-buffer (...)
  ...
  (should (equal "..." (buffer-string))))
@end example

you’d write:

@example
(should (equal "..." (turtles-to-string ...)))
@end example

This is shorter, but doesn’t make the buffer available for
inspection when the test fails.
@end table

The two macros above form the frontend of the Turtles grabbing
functionality. Usually, that’s all you need. The functions below
provide the functionality offered by these frontends and are only
useful if you choose to use neither @code{turtles-with-grab-buffer}


@table @asis

@item (turtles-grab-frame &optional win grab-faces) : function

This puts the content of the terminal frame into the current
buffer and sets the point at the position where the cursor is.

WIN is a window that must be selected while grabbing.

GRAB-FACES is a list of face symbols to grab. See the
description of the :faces argument on
@ref{c,,turtles-with-grab-buffer} for details.

@item (turtles-grab-window win &optional grab-faces margin) : function

This function puts the content of WIN into the current buffer
and puts the point at the position where the cursor is.

GRAB-FACES is a list of face symbols to grab. See the
description of the :faces argument on
@ref{c,,turtles-with-grab-buffer} for details.

If MARGIN is non-nil, grab not only the body of the window, but
also the left and right margins.

@item (turtles-grab-buffer buf &optional grab-faces margins) : function

This function grabs BUF into the current buffer.

If BUF is shown on a window already, that window is the one
that’s grabbed. Otherwise, BUF is installed in the root window
of the frame before grabbing.

This function otherwise behaves as @code{turtles-grab-window}.
See that function for details.

@item (turtles-grab-mode-line win-or-buf &optional grab-faces) : function

This function grabs the mode line of the specified WIN-OR-BUF, a
window or buffer.

GRAB-FACES is a list of face symbols to grab. See the
description of the :faces argument on
@ref{c,,turtles-with-grab-buffer} for details.

@item (turtles-grab-header-line win-or-buf &optional grab-faces) : function

This function grabs the header line of the specified WIN-OR-BUF,
a window or buffer.

GRAB-FACES is a list of face symbols to grab. See the
description of the :faces argument on
@ref{c,,turtles-with-grab-buffer} for details.

@item (turtles-mark-text-with-faces alist) : function

This function marks faces does the :face of
@code{turtles-with-grab-buffer}.

It detects the regions with a specific face in the current
buffer and marks them.

It takes a list of, either:


@itemize -

@item 
( face pair ) with pair being a string that can be split into
opening and closing strings, for example “()”, “[]” or even
“<<>>”.

@item 
( face opening closing ) opening being
opening and closing strings, for example “face1:(” “)”
@end itemize

Note that for this function to work, the faces must have been
grabbed by one of the grab functions.

@item (turtles-mark-text-with-face face opening-or-pair &optional closing) : function

This is a shortcut for @code{turtles-mark-text-with-faces} for
marking a single face in the current buffer.

FACE is the symbol of the face to mark, OPENING-OR-PAIR is
either the opening string, or a string that can be split into
opening and closing, such as “()”, CLOSING is the closing
string.

@item (turtles-mark-point STR) : function

This function just calls (insert STR).

@item (turtles-trim-buffer) : function

This function delete trailing whitespaces on all lines and
trailing newlines at the end of the current buffer.
@end table

@node Minibuffer<2>,Instance Management,Screen Grab,Reference
@anchor{reference id1}@anchor{19}@anchor{reference minibuffer}@anchor{10}
@subsection Minibuffer


@geindex function; turtles-with-minibuffer


@table @asis

@item (turtles-with-minibuffer READ &rest BODY) : macro

This macro tests minibuffer or recursive-edit interactions.

The READ section is a single sexp that calls a function that runs
on the minibuffer or within a recursive-edit. When this function
returns, the macro ends and returns the result of evaluating READ.

The BODY section is a series of sexp that is executed
interactively `while the READ section runs'. This isn’t
multi-threading; @code{turtles-with-minibuffer} waits for the
READ sections to call @code{recursive-edit}, usually indirectly
through @code{read-from-minibuffer}, and runs BODY within that
interactive session.

BODY is usually a mix of:


@itemize -

@item 
calls to @code{turtles-with-grab-buffer} to test the content of
the minibuffer or any other window.

@item 
keys passed to the minibuffer, with :keys, see below.

@item 
commands that manipulate the minibuffer, either called directly
or using :command, see below.
@end itemize

At the end of BODY, the minibuffer is closed, if needed, and
control returns to READ, which checks the result of running BODY.

Special forms are available within BODY to simulate the user inputing
events using the command loop. In contrast to @code{execute-kbd-macro},
@code{ert-simulate-commands} and @code{ert-simulate-keys}, these
function use the real event loop, triggered by real, external events
(terminal keys). This isn’t as simulation.


@table @asis

@item :keys keys

This expression provides KEYS as user input to the minibuffer.

KEYS is in the same format as passed to @code{kbd}.

@item :events events

This expression provides a vector of events as the user input
to the minibuffer.

This is more general than the previous function as the events
can be any kind of UI events.

@item :command command

This expression runs the given interactive command in the event
loop, triggered by a key stroke.

@item :command-with-keybinding keybinding command

This expression works as above, but makes sure that the command
will find in @code{(this-command-keys)}, if it asks.
@end table

See the @ref{f,,Minibuffer} and @ref{12,,Faces with Isearch} sections of
the tutorial for usage examples.
@end table

@node Instance Management,Visiting Instance Buffers,Minibuffer<2>,Reference
@anchor{reference instance-management}@anchor{1a}@anchor{reference instances}@anchor{d}
@subsection Instance Management


@geindex function; turtles-start-server
@geindex function; turtles-shutdown
@geindex function; turtles-restart
@geindex struct; turtles-instance
@geindex function; turtles-definstance
@geindex function; turtles-get-instance
@geindex variable; turtles-instance-alist
@geindex function; turtles-instance-shortdoc
@geindex function; turtles-instance-live-p
@geindex function; turtles-instance-eval
@geindex function; turtles-start-instance
@geindex function; turtles-stop-instance
@geindex function; turtles-read-instance
@geindex variable; turtles-live-instances

Turtles starts secondary Emacs instances from the main process. These
instances run the same version of Emacs with the same
@code{load-path}, in vanilla mode, without configuration.

The secondary Emacs instances are run within a hidden
@code{term-mode} buffer, which is grabbed upon request and sent to
the instances.

The main Emacs process communicates with the secondary instances using
socket communication described in the @ref{17,,next section}. On
startup, the instances connect to the server, and, from then on,
communicate with the server through RPCs.

There can be multiple secondary instances, identified by a symbol,
their ID. Instances with different ids have different characteristics,
defined by @code{turtles-definstance}, described below.

Turtles defines one shared instance in a 80x25 terminal whose ID is
‘default. This is the instance used by ERT tests unless specified
otherwise.

Secondary instances can be started and stopped independently using
@code{turtles-start-instance} and @code{turtles-stop-instance}, and
communicated with using @code{turtles-instance-eval}.

When developing, the versions of elisp libraries might get out of sync
between the main Emacs process and secondary instances. In such a
case, the simplest thing to do is to restart the instances with
@code{turtles-restart}.


@table @asis

@item (turtles-start-server) : function

This function starts a @ref{17,,turtles-io-server} for instances
to connect to. It doesn’t start any instances.

Calling this function is usually not necessary, the server is
started automatically before starting the first instance.

@item (turtles-shutdown) : command

This function shuts down the current @ref{17,,turtles-io-server}, if any, as well as all instances connected to it.

@item (turtles-restart) : command

This function shuts down the current server, then restarts any
live instances.

@item (cl-defstruct turtles-instance id doc conn width height forward setup term-buf): struct

This structure stores information about instances.

Use @code{turtles-definstance} to create and register instances
of this struct and call @code{turtles-get-instance} to find an
instance by its ID.

ID is the instance ID.

CONN is the @ref{17,,turtles-io-conn} to use to communicate
with the instance.

WIDTH, WEIGHT, FORWARD and SETUP are as passed to
@code{turtles-definstance}, see below for details.

TERM-BUF is the term-mode buffer within which the instance is
running, if it is running.

@item (turtles-definstance id (&key …) doc setup) : macro

Define a new instance with the given ID.

Turtles defines a shared instance with ID @code{default}. This is
the instance used by @ref{b,,turtle-ert-test} unless a
specific one is given. The default instance starts a 80x24
terminal with no setup.

Define your own custom instance whenever you need a different
screen size, setup or to forward the value of variables at
startup.

Make sure you set at least a short documentation in DOC. This
documentation is displayed in the prompt of
@code{turtles-start-instance}, @code{turtles-stop-instance} and
in the message issued when an instance is started.

The code in SETUP is executed before every ERT test. This is a
convenient place to put Emacs instance setup that you want to
remain constant across tests.

This macro takes the following key arguments:

:width WIDTH and :height HEIGHT to set the dimensions of the
terminal.

:forward SYMBOL-LIST provides a list of variable symbols whose
value should be copied to the instance at launch. This is useful
if you have variables whose value influence the tests that you
want to remain consistent between the main Emacs process and the
secondary instance.

@item (turtles-get-instance inst-or-id) : function

This function returns a @code{turtles-instance}. Given an ID, it
returns the instance with that ID, or nil if it cannot be found.

Given a @code{turtles-instance}, it returns that instance. This
is useful to setup functions that take either an ID or an
instance. Such function just need to call
@code{turtles-get-instance} at startup.

@item (turtles-instance-alist) : variable

This alist maps @code{turtles-instance} IDs to their value.

This alist is normally only filled by @code{turtles-definstance}.

@item (turtles-instance-shortdoc inst-or-id) : function

Return a short description for the given @code{turtles-instance}
or ID.

The short description is built by taking the first line of the
documentation set in @code{turtles-definstance}.

@item (turtles-instance-live-p inst) : function

Return non-nil if the given instance is live.

@item (turtles-instance-eval inst-or-id expr &key timeout) : function

Evaluate EXPR on the given instance, identified by its ID or
@code{turtle-instance}.

This function waits for the evaluation to finish and returns the
result of that evaluation. If that evaluation is likely to take
time, set TIMEOUT to a value longer than the default 10s.

@item (turtles-start-instance inst-or-id) : command

Start the given instance, unless it is already started.

If called interactively, ask for the instance to start among the
registered instances that aren’t live yet.

@item (turtles-stop-instance inst-or-id) : command

Stop the given instance, if it is running.

If called interactively, ask for the instance to stop among the
registered instances that are currently live.

@item (turtles-read-instance &optional prompt predicate) : function

Ask the use to choose an instance among those for which PREDICATE
evaluates to t.

PROMPT is displayed in the minibuffer.

PREDICATE takes a @code{turtles-instance} and should return
non-nil to accept that instance.

@item (turtles-live-instances) : function

Return the IDs of all live instances.
@end table

@node Visiting Instance Buffers,RPC turtles-io,Instance Management,Reference
@anchor{reference visit}@anchor{1b}@anchor{reference visiting-instance-buffers}@anchor{1c}
@subsection Visiting Instance Buffers


When a ERT tests is run inside a secondary Emacs instance, buffers
referenced in the test result should be looked up in the instance that
ran the test, and not the main Emacs process.

Such remote processes can be found in the test result or backtrace as
@code{'(turtles-buffer :name "..." :instance id)}. To visit such a
buffer, call @code{turtles-pop-to-buffer}

@geindex function; turtles-new-frame-in-instance
@geindex function; turtles-pop-to-buffer
@geindex function; turtles-pop-to-buffer-embedded
@geindex function; turtles-pop-to-buffer-copy
@geindex function; turtles-pop-to-buffer-new-frame
@geindex function; turtles-pop-to-buffer-actions
@geindex function; turtles-pop-to-buffer-action-history


@table @asis

@item (turtles-new-frame-in-instance inst-or-id) : command

When the main Emacs instance is run in a windowing environment,
you can ask the secondary Emacs instance to open a new frame and
inspect its state with this function.

When called interactively, it lets the use choose an instance
among those currently live.

@item (turtles-pop-to-buffer buffer) : function

This function displays buffers of the form @code{'(turtles-buffer :name "..." :instance id)}

To do so, it looks in @code{turtles-pop-to-buffer-actions} for
available actions and ask the user to choose one if there are more
than one. To skip this step, make sure that there’s only one
action on that list.

@item (turtles-pop-to-buffer-embedded …) : function

This function displays a buffer from another instance in the
terminal buffer of the main Emacs process. It is meant to be called
by @code{turtles-pop-buffer}.

@item (turtles-pop-to-buffer-copy …) : function

This function makes a copy of a buffer in another instance and
displays it in the main Emacs process. It is meant to be called by
@code{turtles-pop-buffer}.

@item (turtles-pop-to-buffer-new-frame …) : function

This function tells the secondary instance owning the buffer to
display to open a new frame showing that buffer. Only works if the
main Emacs process is running in a windowing environment. It is
meant to be called by @code{turtles-pop-buffer}.

@item (turtles-pop-to-buffer-actions) : variable

List of actions that @code{turtles-pop-to-buffer} should consider.
@end table

@node RPC turtles-io,,Visiting Instance Buffers,Reference
@anchor{reference rpc}@anchor{17}@anchor{reference rpc-turtles-io}@anchor{1d}
@subsection RPC (turtles-io)


@geindex function; turtles-io-server
@geindex struct; turtles-io-server
@geindex function; turtles-io-server-live-p
@geindex function; turtles-io-connect
@geindex struct; turtles-io-conn
@geindex function; turtles-io-conn-live-p
@geindex variable; turtles-io-unreadable-obj-props
@geindex function; turtles-io-handle-method
@geindex function; turtles-io-send-error
@geindex function; turtles-io-send-result
@geindex function; turtles-io-call-method
@geindex function; turtles-io-notify
@geindex function; turtles-io-call-method-async

turtles-io defines a very simple communication protocol for Emacs
instances to communicate with each other, inspired from JSON-RPC. It
is used to allow the main Emacs process and the secondary instances to
communicate.

The protocol is based on a socket-based communication between the main
Emacs process, the server, and the secondary Emacs instances, the
client.

Each side communicate with the other by sending elisp expressions
separated by @code{n"""n}. Each elisp expression is a message,
which can be of the following types:


@itemize -

@item 
a method call of the form:

@example
(:id id :method method-name :params params)
@end example

METHOD is the method name to call.

ID is used to identify the response when it comes. If no ID is
provided, the method is run, but no response is ever sent back. Such
a method call without ID is called a notification.

PARAMS is a lisp type defined by the method as its parameter. It
might be nil or missing.

@item 
a result of the form:

@example
(:id id :result result)
@end example

This is a response to a previous method call. ID echoes the ID that
was passed to that call and RESULT is a lisp expression that the
method returns. It might be nil, but it cannot be missing.

@item 
an error of the form:

@example
(:id id :error error)
@end example

This is a response to a previous method call. ID echoes the ID that
was passed to that call and RESULT should be a list expression of the same
type as those captured by @code{condition-case}. The CAR of that list is
an error symbol and the CDR its argument. Note that different processes
might not agree on the set of defined error symbols, so it is possible to
receive an error whose CAR is not an error symbol.
@end itemize

The elisp expressions are serialized using @code{prn1} and read back
using @code{read}. Many Emacs types cannot be serialized that way, so
Turtles defines placeholders for them:

@quotation


@itemize -

@item 
buffers: (turtles-buffer :name NAME) or (turtles-buffer :live
nil). Such placeholders can be opened from the main Emacs process
with @ref{1b,,pop-to-buffer}

@item 
window: (turtles-buffer :buffer BUFFER-NAME)

@item 
overlay: (turtles-overlay :from POS :to POS :buffer BUFFER-NAME)

@item 
marker: (turtles-marker :pos POS :buffer BUFFER-NAME)

@item 
frame: (turtles-frame :name TITLE)

@item 
anything else: (turtle-obj :type TYPE)
@end itemize
@end quotation

When running inside of a secondary Emacs instance, such placeholder
type are extended to include :instance ID to identify the source
instance.


@table @asis

@item (turtles-io-server socket &optional method-alist) : function

Create a new server, listening to the given SOCKET file.

METHOD-ALIST associates method ID to method handlers. A method
handles takes 4 arguments: conn, id, method, params and should
call one of @code{turtles-io-send-result} or
@code{turtles-io-send-error} once it is finished.

Return an instance of type @code{turtles-io-server}.

@item (turtles-io-server-live-p server) : function

Return non-nil if the given @code{turtles-io-server} instance is live.

@item (turtles-io-connect socket &optional method-alist) : function

Connect to a server running at the given SOCKET file.

METHOD-ALIST associates method ID to method handlers. A method
handles takes 4 arguments: conn, id, method, params and should
call one of @code{turtles-io-send-result} or
@code{turtles-io-send-error} once it is finished.

Return an instance of type @code{turtles-io-conn}.

@item turtles-io-conn : struct

This type represents a connection to some other Emacs instance.

@item (turtles-io-conn-live-p conn) : function

Retrun non-nil if the given @code{turtles-io-conn} is live.

@item (turtles-io-unreadable-obj-props) : variable

Properties to add to any placeholder generated for unreadable
(unserializable) objects such as buffers.

@item (turtles-io-handle-method conn method params (&key timeout)) : function

Call the given method on the connection with the given parameters.

This function waits for the result and returns it. If the call
returns an error, that error is sent as an signal.

@item (turtles-io-call-method-async conn method params handler) : function

Alternative to the above method that doesn’t wait for the result.
The result or the error is instead passed to the given handler,
which should take two arguments: result and error, only one of
which is ever non-nil.

@item (turtles-io-notify conn method &optional params) : function

Alternative to the above methods that doesn’t expect a result.

@item (turtles-io-send-error conn id error) : function

Send an error back to the called. Does nothing if the id is nil.

@item (turtles-io-send-result) : function

Send a result back to the called. Does nothing if the id is nil.
@end table

@node Contributing,,Reference,Contents
@anchor{contrib doc}@anchor{1e}@anchor{contrib contributing}@anchor{1f}
@section Contributing


@menu
* Reporting issues:: 
* Suggesting features:: 
* Asking questions:: 
* Code contributions:: 
* Documentation contributions:: 

@end menu

@node Reporting issues,Suggesting features,,Contributing
@anchor{contrib reporting}@anchor{20}@anchor{contrib reporting-issues}@anchor{21}
@subsection Reporting issues


At this time, the most useful thing you can do to help is and useful
bug reports to the Issue Tracker@footnote{https://github.com/szermatt/turtles/issues}

In your report, please discuss what you wanted to happen as well as
what happened. Also, please include enough information to reproduce
the issue.

Please include:


@itemize -

@item 
the version of Emacs you’re running, taken, for example, from
@code{M-x about-emacs}

@item 
whether you’re running Emacs in a window environment or a terminal
@end itemize

@node Suggesting features,Asking questions,Reporting issues,Contributing
@anchor{contrib suggesting-features}@anchor{22}
@subsection Suggesting features


Please add feature suggestions to the Issue Tracker@footnote{https://github.com/szermatt/turtles/issues}.

@node Asking questions,Code contributions,Suggesting features,Contributing
@anchor{contrib asking-questions}@anchor{23}
@subsection Asking questions


Start a discussion@footnote{https://github.com/szermatt/turtles/discussions} with your question.

@node Code contributions,Documentation contributions,Asking questions,Contributing
@anchor{contrib code-contributions}@anchor{24}
@subsection Code contributions


To contribute code to the project, open a Pull Request@footnote{https://github.com/szermatt/turtles/pulls}.

Before you do that, please make sure the any new features is covered
by tests and that the tests pass.

To run the tests, install and setup eldev@footnote{https://github.com/emacs-eldev/eldev}, then run @code{eldev
test}.

Tests can also be run from inside of Emacs, using @cite{M-x ert-run-tests-interactively} but when you do so, be aware that there
might be unexpected interaction with your Emacs configurations. The
tests passing reliably when run using @code{eldev test} is what
matters.

Please also make sure your commit message follows Conventional Commits 1.0.0@footnote{https://www.conventionalcommits.org/en/v1.0.0/}.

@node Documentation contributions,,Code contributions,Contributing
@anchor{contrib documentation-contributions}@anchor{25}@anchor{contrib eldev}@anchor{26}
@subsection Documentation contributions


You don’t need to be a developer to contribute! Contribution to the
documentation or code comments are very welcome. Please open a Pull Request@footnote{https://github.com/szermatt/turtles/pulls} with your proposed modifications.

The documentation is written in reStructuredText. You’ll need to
install Sphinx@footnote{https://www.sphinx-doc.org} to build it:

@example
python3 -m venv venv
. venv/bin/activate # or activate.fish on fish
pip3 install -r docs/requirements.txt
@end example

Then run @code{eldev html} to build the documentation.

@node Index,,Contents,Top
@unnumbered Index


@printindex ge


@c %**end of body
@bye
