\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename turtles.info
@documentencoding UTF-8
@ifinfo
@*Generated by Sphinx.@*
@end ifinfo
@settitle Visual Replace
@defindex ge
@paragraphindent 0
@exampleindent 4
@finalout
@dircategory Emacs
@direntry
* turtles: (turtles.info). Library for writing ERT-based tests that check how
                        Emacs renders buffers and windows.
@end direntry

@c %**end of header

@copying
@quotation
Turtles

Stephane Zermatten

Copyright @copyright{} 2024, Stephane Zermatten
@end quotation

@end copying

@titlepage
@title Visual Replace
@insertcopying
@end titlepage
@contents

@c %** start of user preamble

@c %** end of user preamble

@ifnottex
@node Top
@top Visual Replace
@insertcopying
@end ifnottex

@c %**start of body
@anchor{index doc}@anchor{0}
TODO

@menu
* Contents:: 
* Index:: 

@detailmenu
 --- The Detailed Node Listing ---

Contents

* Installation:: 
* Tutorial:: 
* Reference:: 
* Contributing:: 

Tutorial

* Screen Grabbing:: 
* Minibuffer:: 
* Faces and Point:: 

Reference

* ERT Integration:: 
* Screen Grab:: 
* Minibuffer: Minibuffer<2>. 
* Input Events:: 
* Instance Management:: 
* Visiting Instances:: 
* RPC (turtles-io): RPC turtles-io. 

Contributing

* Reporting issues:: 
* Suggesting features:: 
* Asking questions:: 
* Code contributions:: 
* Documentation contributions:: 

@end detailmenu
@end menu

@node Contents,Index,Top,Top
@anchor{index contents}@anchor{1}@anchor{index turtles}@anchor{2}
@chapter Contents


@menu
* Installation:: 
* Tutorial:: 
* Reference:: 
* Contributing:: 

@end menu

@node Installation,Tutorial,,Contents
@anchor{install doc}@anchor{3}@anchor{install install}@anchor{4}@anchor{install installation}@anchor{5}
@section Installation


TODO

Turtles requires Emacs 26.1 or later.

@node Tutorial,Reference,Installation,Contents
@anchor{tutorial doc}@anchor{6}@anchor{tutorial tut}@anchor{7}@anchor{tutorial tutorial}@anchor{8}
@section Tutorial


Turtles is a collection of tools for writing ERT tests that look at
the terminal showing an interactive Emacs instance from within that
instance. That is, you can setup buffer content and windows and check
how it looks like to a user running Emacs in a terminal.

Such ERT tests can run in batch mode as well an in interactive mode.

To make that work, Turtles starts a secondary Emacs instance from
within a terminal buffer. Tests run in the secondary Emacs instance
and their result communicated to the primary Emacs instance. Whenever
needed, the primary instance grab the screen and provides the result,
that is, a terminal screen with colors and cursor position, to the
secondary instance.

To get started, @ref{4,,install turtles}, create a new ERT
test file with:

@example
;; -*- lexical-binding: t -*-

(require 'ert)
(require 'ert-x)
(require 'turtles)
@end example

If you checked out the source from
@indicateurl{https://github.com/szermatt/turtles}, you’ll find the tests shown
in this tutorial in the file test/turtles-example-test.el@footnote{https://github.com/szermatt/turtles/blob/master/test/turtles-examples-test.el}
and you can run them interactively or in batch mode using @code{eldev
test}.

@menu
* Screen Grabbing:: 
* Minibuffer:: 
* Faces and Point:: 

@end menu

@node Screen Grabbing,Minibuffer,,Tutorial
@anchor{tutorial screen-grabbing}@anchor{9}@anchor{tutorial tut-hello-world}@anchor{a}
@subsection Screen Grabbing


To get started, let’s create a test that creates a buffer, renders it
and check the result:

@example
(ert-deftest turtles-examples-hello-world ()
   ;; Start a secondary Emacs instance
  (turtles-ert-test)

  ;; From this point, everything runs in the secondary instance.
  (ert-with-test-buffer ()
    (insert "hello, ") ; Fill in the buffer
    (insert (propertize "the " 'invisible t))
    (insert "world!\n")

    (turtles-with-grab-buffer () ; Grab current buffer content
      (should (equal "hello, world!"
                     (buffer-string))))))
@end example

The first call in the test is @ref{b,,(turtles-ert-test)}. This
function creates a secondary Emacs instances, then runs the rest of
the test within that instance.

What Turtles calls instance is a separate Emacs process that
@code{turtles-ert-test} started within a terminal window.

Running within a secondary instance is only useful because it is
needed by @ref{c,,(turtles-with-grab-buffer)}. This macro
displays its containing buffer in a window, grabs the content of that
window and puts than into an ERT test buffer.

The body of @code{turtles-with-grab-buffer} runs within that grabbed
buffer, just like the body of @code{ert-with-test-buffer}. Its content
can be modified and checked with the usual tools.

Obviously, the window that was grabbed didn’t have just two lines and
was larger than just the two words that appear here. What was really
grabbed contained spaces and newlines that
@code{turtles-with-grabbed} trimmed automatically to make it easier
to test.

Try passing the option @code{:trim t} and running the test with
@code{ert-run-tests-interactively}:

@example
(turtles-with-grab-buffer (:trim t)
  (should (equal "hello, world!"
                 (buffer-string))))))
@end example

You’ll then see something like the following:

@example
F turtles-examples-hello-world
    Buffer: *Test buffer (turtles-examples-hello-world)*
    Buffer: *Test buffer (turtles-examples-hello-world): grab*
    (ert-test-failed
     ((should
       (equal "hello, world!"
              (buffer-string)))
      :form
      (equal "hello, world!"
             #("hello, world!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n" 0 13
               (face
                (...))
               13 35
               (face default)))
      :value nil :explanation
      (arrays-of-different-length 13 35 "hello, world!"
                                  #("hello, world!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n" 0 13
                                    (face
                                     (...))
                                    13 35
                                    (face default))
                                  first-mismatch-at 13)))
@end example

As you can see above, the window that was grabbed had a bit more than
20 lines. This corresponds to a single window within a 80x24, the size
of the default @ref{d,,instance}.

The ERT test buffers listed above

@example
Buffer: *Test buffer (turtles-examples-hello-world)*
Buffer: *Test buffer (turtles-examples-hello-world): grab*
@end example

are part of that instance. If you click on either one of these, you’ll
be offered a choice of different ways of seeing these buffers. The
most convenient one, if you’re running in a windowing environment, is
to ask the instance to create a new frame to show the buffer.

@code{turtles-with-grab-buffer} doesn’t just grab the window content,
of course, but actually the whole frame, then strips out everything
that’s outside the window. To better understand what this means, add
the option @code{frame t}, as shown below, and run the tests again:

@example
(turtles-with-grab-buffer (:frame t)
  (should (equal "hello, world!"
                 (buffer-string))))))
@end example

They will fail, and in the error message, or the buffers listed there,
you’ll see the entire Emacs frame that was grabbed, including the mode
line and message area.

Have a look at the @ref{c,,turtles-with-grab-buffer reference} to
see how you can grab other sections of the screen.

@node Minibuffer,Faces and Point,Screen Grabbing,Tutorial
@anchor{tutorial minibuffer}@anchor{e}@anchor{tutorial tut-minibuffer}@anchor{f}
@subsection Minibuffer


This second example illustrates the use of
@ref{10,,(turtles-with-minibuffer)} running
@code{completing-read}:

@example
(ert-deftest turtles-examples-test-completing-read ()
  (turtles-ert-test)

  (ert-with-test-buffer ()
    (let ((completing-read-function #'completing-read-default))
      (turtles-with-minibuffer
          (should
           (equal "Choice B"
                  (completing-read "Choose: " '("Choice A" "Choice B") nil t)))

        (turtles-with-grab-buffer (:name "initial prompt" :point "<>")
          (should (equal "Choose: <>" (buffer-string))))

        (turtles-input-keys "Ch TAB")
        (turtles-with-grab-buffer (:name "completion" :point "<>")
          (should (equal "Choose: Choice <>" (buffer-string))))

        (turtles-input-keys "B")))))
@end example

@code{turtles-with-minibuffer} takes as argument two separate sections, as shown below:

@example
(turtles-with-minibuffer
    READ
  BODY)
@end example

The READ section is a single sexp that calls a function that runs on
the minibuffer or within a recursive-edit. When this function returns,
@code{turtles-with-minibuffer} ends and returns the result of
evaluating READ.

The example above doesn’t care about what READ evaluates to, because
it checks the retrun value of @code{completing-read} directly within
that section.

The BODY section is a series of sexp that is executed interactively
`while the READ section runs'. This isn’t multi-threading;
@code{turtles-with-minibuffer} waits for the READ sections to call
@code{recursive-edit}, usually indirectly through
@code{read-from-minibuffer}, and runs BODY within that interactive
session.

At the end of BODY, the minibuffer is closed, if needed, and control
returns to READ, which checks the result of running BODY.

Within that example BODY first checks the minibuffer content with:

@example
(turtles-with-grab-buffer (:name "initial prompt" :point "<>")
  (should (equal "Choose: <>" (buffer-string))))
@end example

The argument :point tells @code{turtles-with-grab-buffer} to
highlight the position of the cursor with “<>”. You can also just
check that manually; it’s just convenient to see the content and the
position of the point in the same string.

This test interacts with @code{completing-read} by simulating the
user typing some text and pressing @code{TAB}. It uses
@ref{11,,turtles-input-keys} for that, which simulates the user
typing some keys.

The test could have called the command @code{TAB} corresponds to directly:

@example
(turtles-input-keys "Ch")
(minibuffer-complete)
(turtles-with-grab-buffer (:name "completion" :point "<>")
  (should (equal "Choose: Choice <>" (buffer-string))))
@end example

Calling interactive commands in such a way in a test is usually
clearer than going through key bindings, and in most cases, it works well.

Some commands that rely on the specific environment provided by the
command loop won’t work if called directly.
@ref{11,,turtles-input-command} can help with such commands,
though it’s just overkill here:

@example
(turtles-input-keys "Ch")
(turtles-input-command #'minibuffer-complete)
(turtles-with-grab-buffer (:name "completion" :point "<>")
  (should (equal "Choose: Choice <>" (buffer-string))))
@end example

@node Faces and Point,,Minibuffer,Tutorial
@anchor{tutorial faces-and-point}@anchor{12}@anchor{tutorial tut-isearch}@anchor{13}
@subsection Faces and Point


This last example tests isearch. While not a minibuffer-based command,
isearch still works with @code{turtles-with-minibuffer}.

@example
(ert-deftest turtles-examples-test-isearch ()
  (turtles-ert-test)

  (ert-with-test-buffer ()
    (let ((testbuf (current-buffer)))
      (select-window (display-buffer testbuf))
      (delete-other-windows)

      (insert "Baa, baa, black sheep, have you any wool?")
      (goto-char (point-min))

      (turtles-with-minibuffer
          (isearch-forward nil 'no-recursive-edit)

        (turtles-input-keys "baa")
        (turtles-with-grab-buffer (:minibuffer t)
          (should (equal "I-search: baa" (buffer-string))))
        (turtles-with-grab-buffer (:buf testbuf :name "match 1" :faces '((isearch . "[]")))
          (should (equal "[Baa], baa, black sheep, have you any wool?"
                         (buffer-string))))

        (turtles-input-keys "\C-s")
        (turtles-with-grab-buffer (:buf testbuf :name "match 2" :faces '((isearch . "[]")))
          (should (equal "Baa, [baa], black sheep, have you any wool?"
                         (buffer-string))))

        (isearch-done))

      (turtles-with-grab-buffer (:name "final position" :point "<>")
        (should (equal "Baa, baa<>, black sheep, have you any wool?"
                       (buffer-string)))))))
@end example

The interesting bit here is:

@example
(turtles-with-grab-buffer (:buf testbuf :name "match 1" :faces '((isearch . "[]")))
  (should (equal "[Baa], baa, black sheep, have you any wool?"
                 (buffer-string))))
@end example

This test is used to check which part of the buffer isearch
highlighted.

The argument :faces tells @code{turtles-with-grab-buffer} to grab a
small set of faces and make them available in the buffer as the text
property ‘face.

This example additionally asks @code{turtles-with-grab-buffer} to
detect portions of the buffer with such a face and surround them with
brackets, to make it more convenient to test.

Faces aren’t available in a terminal, of course. Turtles uses colors
to highlight the faces it’s interested in, then processes the grabbed
data to recognize the faces it wants from these colors it has
assigned.

@node Reference,Contributing,Tutorial,Contents
@anchor{reference doc}@anchor{14}@anchor{reference ref}@anchor{15}@anchor{reference reference}@anchor{16}
@section Reference


@menu
* ERT Integration:: 
* Screen Grab:: 
* Minibuffer: Minibuffer<2>. 
* Input Events:: 
* Instance Management:: 
* Visiting Instances:: 
* RPC (turtles-io): RPC turtles-io. 

@end menu

@node ERT Integration,Screen Grab,,Reference
@anchor{reference ert}@anchor{b}@anchor{reference ert-integration}@anchor{17}
@subsection ERT Integration


@geindex function; turtles-ert-test
@geindex function; turtles-upstream
@geindex function; turtles-this-instance

@code{turtles-ert-test} : macro

@code{turtles-upstream} : function

@code{turtles-this-instance} : function

@node Screen Grab,Minibuffer<2>,ERT Integration,Reference
@anchor{reference grab}@anchor{c}@anchor{reference screen-grab}@anchor{18}
@subsection Screen Grab


@geindex function; turtles-with-grab-buffer
@geindex function; turtles-to-string
@geindex function; turtles-mark-text-with-face
@geindex function; turtles-mark-text-with-faces
@geindex function; turtles-mark-point
@geindex function; turtles-trim-buffer
@geindex function; turtles-grab-frame
@geindex function; turtles-grab-buffer
@geindex function; turtles-grab-mode-line
@geindex function; turtles-grab-header-line
@geindex function; turtles-grab-window

@code{turtles-with-grab-buffer} : macro

@code{turtles-to-string} : macro

@code{turtles-mark-text-with-face} : function

@code{turtles-mark-text-with-faces} : function

@code{turtles-mark-point} : function

@code{turtles-trim-buffer} : function

@code{turtles-grab-frame} : function

@code{turtles-grab-buffer} : function

@code{turtles-grab-mode-line} : function

@code{turtles-grab-header-line} : function

@code{turtles-grab-window} : function

@node Minibuffer<2>,Input Events,Screen Grab,Reference
@anchor{reference id1}@anchor{19}@anchor{reference minibuffer}@anchor{10}
@subsection Minibuffer


@geindex function; turtles-with-minibuffer

@code{turtles-with-minibuffer} : macro

@node Input Events,Instance Management,Minibuffer<2>,Reference
@anchor{reference input}@anchor{11}@anchor{reference input-events}@anchor{1a}
@subsection Input Events


@geindex function; turtles-input-keys
@geindex function; turtles-input-events
@geindex function; turtles-input-command

@code{turtles-input-keys} : function

@code{turtles-input-events} : function

@code{turtles-input-command} : function

@node Instance Management,Visiting Instances,Input Events,Reference
@anchor{reference instance-management}@anchor{1b}@anchor{reference instances}@anchor{d}
@subsection Instance Management


@geindex function; turtles-start-server
@geindex function; turtles-shutdown
@geindex function; turtles-restart
@geindex struct; turtles-instance
@geindex function; turtles-definstance
@geindex function; turtles-get-instance
@geindex variable; turtles-instance-alist
@geindex function; turtles-instance-shortdoc
@geindex function; turtles-instance-live-p
@geindex function; turtles-instance-eval
@geindex function; turtles-start-instance
@geindex function; turtles-stop-instance
@geindex function; turtles-read-instance
@geindex variable; turtles-live-instances

@code{turtles-start-server} : function

@code{turtles-shutdown} : function

@code{turtles-restart} : function

@code{turtles-instance} : struct

@code{turtles-definstance} : macro

@code{turtles-get-instance} : function

@code{turtles-instance-alist} : variable

@code{turtles-instance-shortdoc} : function

@code{turtles-instance-live-p} : function

@code{turtles-instance-eval} : function

@code{turtles-start-instance} : function

@code{turtles-stop-instance} : function

@code{turtles-read-instance} : function

@code{turtles-live-instances} : variable

@node Visiting Instances,RPC turtles-io,Instance Management,Reference
@anchor{reference visit}@anchor{1c}@anchor{reference visiting-instances}@anchor{1d}
@subsection Visiting Instances


@geindex function; turtles-new-frame-in-instance
@geindex function; turtles-pop-to-buffer
@geindex function; turtles-pop-to-buffer-embedded
@geindex function; turtles-pop-to-buffer-copy
@geindex function; turtles-pop-to-buffer-new-frame
@geindex function; turtles-pop-to-buffer-actions
@geindex function; turtles-pop-to-buffer-action-history

@code{turtles-new-frame-in-instance} : function

@code{turtles-pop-to-buffer} : function

@code{turtles-pop-to-buffer-embedded} : function

@code{turtles-pop-to-buffer-copy} : function

@code{turtles-pop-to-buffer-new-frame} : function

@code{turtles-pop-to-buffer-actions} : function

@code{turtles-pop-to-buffer-action-history} : function

@node RPC turtles-io,,Visiting Instances,Reference
@anchor{reference rpc}@anchor{1e}@anchor{reference rpc-turtles-io}@anchor{1f}
@subsection RPC (turtles-io)


@geindex function; turtles-io-server
@geindex struct; turtles-io-server
@geindex function; turtles-io-server-live-p
@geindex function; turtles-io-connect
@geindex struct; turtles-io-conn
@geindex function; turtles-io-conn-live-p
@geindex variable; turtles-io-unreadable-obj-props
@geindex function; turtles-io-handle-method
@geindex function; turtles-io-send-error
@geindex function; turtles-io-send-result
@geindex function; turtles-io-call-method
@geindex function; turtles-io-notify
@geindex function; turtles-io-call-method-async

@code{turtles-io-server} : function

@code{turtles-io-server} : struct

@code{turtles-io-server-live-p} : function

@code{turtles-io-connect} : function

@code{turtles-io-conn} : struct

@code{turtles-io-conn-live-p} : function

@code{turtles-io-unreadable-obj-props} : variable

@code{turtles-io-handle-method} : function

@code{turtles-io-send-error} : function

@code{turtles-io-send-result} : function

@code{turtles-io-call-method} : function

@code{turtles-io-notify} : function

@code{turtles-io-call-method-async} : function

@node Contributing,,Reference,Contents
@anchor{contrib doc}@anchor{20}@anchor{contrib contributing}@anchor{21}
@section Contributing


@menu
* Reporting issues:: 
* Suggesting features:: 
* Asking questions:: 
* Code contributions:: 
* Documentation contributions:: 

@end menu

@node Reporting issues,Suggesting features,,Contributing
@anchor{contrib reporting}@anchor{22}@anchor{contrib reporting-issues}@anchor{23}
@subsection Reporting issues


At this time, the most useful thing you can do to help is and useful
bug reports to the Issue Tracker@footnote{https://github.com/szermatt/turtles/issues}

In your report, please discuss what you wanted to happen as well as
what happened. Also, please include enough information to reproduce
the issue.

Please include:


@itemize -

@item 
the version of Emacs you’re running, taken, for example, from
@code{M-x about-emacs}

@item 
whether you’re running Emacs in a window environment or a terminal
@end itemize

@node Suggesting features,Asking questions,Reporting issues,Contributing
@anchor{contrib suggesting-features}@anchor{24}
@subsection Suggesting features


Please add feature suggestions to the Issue Tracker@footnote{https://github.com/szermatt/turtles/issues}.

@node Asking questions,Code contributions,Suggesting features,Contributing
@anchor{contrib asking-questions}@anchor{25}
@subsection Asking questions


Start a discussion@footnote{https://github.com/szermatt/turtles/discussions} with your question.

@node Code contributions,Documentation contributions,Asking questions,Contributing
@anchor{contrib code-contributions}@anchor{26}
@subsection Code contributions


To contribute code to the project, open a Pull Request@footnote{https://github.com/szermatt/turtles/pulls}.

Before you do that, please make sure the any new features is covered
by tests and that the tests pass.

To run the tests, install and setup eldev@footnote{https://github.com/emacs-eldev/eldev}, then run @code{eldev
test}.

Tests can also be run from inside of Emacs, using @cite{M-x ert-run-tests-interactively} but when you do so, be aware that there
might be unexpected interaction with your Emacs configurations. The
tests passing reliably when run using @code{eldev test} is what
matters.

Please also make sure your commit message follows Conventional Commits 1.0.0@footnote{https://www.conventionalcommits.org/en/v1.0.0/}.

@node Documentation contributions,,Code contributions,Contributing
@anchor{contrib documentation-contributions}@anchor{27}@anchor{contrib eldev}@anchor{28}
@subsection Documentation contributions


You don’t need to be a developer to contribute! Contribution to the
documentation or code comments are very welcome. Please open a Pull Request@footnote{https://github.com/szermatt/turtles/pulls} with your proposed modifications.

The documentation is written in reStructuredText. You’ll need to
install Sphinx@footnote{https://www.sphinx-doc.org} to build it:

@example
python3 -m venv venv
. venv/bin/activate # or activate.fish on fish
pip3 install -r docs/requirements.txt
@end example

Then run @code{eldev html} to build the documentation.

@node Index,,Contents,Top
@unnumbered Index


@printindex ge


@c %**end of body
@bye
