\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename turtles.info
@documentencoding UTF-8
@ifinfo
@*Generated by Sphinx.@*
@end ifinfo
@settitle Visual Replace
@defindex ge
@paragraphindent 0
@exampleindent 4
@finalout
@dircategory Emacs
@direntry
* turtles: (turtles.info). Library for writing ERT-based tests that check how
                        Emacs renders buffers and windows.
@end direntry

@c %**end of header

@copying
@quotation
Turtles

Stephane Zermatten

Copyright @copyright{} 2024, 2025, Stephane Zermatten
@end quotation

@end copying

@titlepage
@title Visual Replace
@insertcopying
@end titlepage
@contents

@c %** start of user preamble

@c %** end of user preamble

@ifnottex
@node Top
@top Visual Replace
@insertcopying
@end ifnottex

@c %**start of body
@anchor{index doc}@anchor{0}
Turtles is an Emacs elisp package that helps write ERT-based tests
that check how Emacs renders buffers and windows. The ERT tests can be
run interactively or in batch mode. You’ll find the source code of
this package on @indicateurl{https://github.com/szermatt/turtles}

Go to @ref{1,,Tutorial} to get started.

Turtles is especially suited to test:


@itemize -

@item 
the effect of display, before-string, after-string text properties

@item 
the effect of overlays

@item 
text visibility

@item 
mode lines

@item 
complex minibuffer interactions
@end itemize

`This program is free software: you can redistribute it and/or
modify it under the terms of the GNU General Public License as
published by the Free Software Foundation; either version 3 of the
License, or (at your option) any later version.'

`This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.'

`You should have received a copy of the GNU General Public License
along with this program.  If not, see' @indicateurl{http://www.gnu.org/licenses/}

@menu
* Contents:: 
* Index:: 

@detailmenu
 --- The Detailed Node Listing ---

Contents

* Installation:: 
* Tutorial:: 
* Reference:: 
* Contributing:: 

Tutorial

* Screen Grabbing with Hello World:: 
* Minibuffer with completing-read:: 
* Faces with Isearch:: 

Reference

* ERT Integration:: 
* Screen Grab:: 
* Minibuffer:: 
* Instance Management:: 
* Visiting Instance Buffers:: 
* RPC (turtles-io): RPC turtles-io. 

Contributing

* Reporting issues:: 
* Suggesting features:: 
* Asking questions:: 
* Code contributions:: 
* Documentation contributions:: 

@end detailmenu
@end menu

@node Contents,Index,Top,Top
@anchor{index contents}@anchor{2}@anchor{index turtles}@anchor{3}
@chapter Contents


@menu
* Installation:: 
* Tutorial:: 
* Reference:: 
* Contributing:: 

@end menu

@node Installation,Tutorial,,Contents
@anchor{install doc}@anchor{4}@anchor{install install}@anchor{5}@anchor{install installation}@anchor{6}
@section Installation


Install Turtles:


@itemize -

@item 
on a recent version of Emacs (29 or later), from the
github repository by doing @code{M-x package-vc-install
https://github.com/szermatt/turtles}

@item 
from source, using an alternative package managers, such as straight@footnote{https://github.com/radian-software/straight.el}, shown here:

@example
(use-package turtles
  :straight (:type git :repo "https://github.com/szermatt/turtles.git"))
@end example

@item 
from MELPA@footnote{https://melpa.org/#/getting-started}, by typing @cite{M-x package-install turtles}.

Note that there’s no practical difference between the stable and
unstable MELPA package, as development happens on a branch. Both
stable and unstable include the latest release of the code, unstable
may contain a more recent version of the .info doc.

@item 
the old-fashioned way, copying the .el files from into your
@code{.emacs.d} directory.

@item 
using eldev@footnote{https://github.com/emacs-eldev/eldev} to run tests in batch mode:

@example
(eldev-add-extra-dependencies 'test 'turtles)
(eldev-use-vc-repository 'turtles :github "szermatt/turtles" :commit "1.0.0")
@end example
@end itemize

This latest way is very much recommended as it allows specifying a version. To
avoid surprises, you should aim to depend on a specific, tagged
version and only increase that version when you need to.

This project follows Semantic Versioning 2.0.0@footnote{https://semver.org/} that is, versions follow the format
MAJOR.MINOR.PATCH with:


@itemize -

@item 
MAJOR incremented for incompatible API changes

@item 
MINOR incremented when when functionality is added that is backward-compatible

@item 
PATCH for bugfixes
@end itemize

Versions with “snapshot” appended, such as “1.3.1snapshot” are
development version and cannot be depended on. Please always work with
tagged versions.

Turtles requires Emacs 26.1 or later. Emacs 29.1 or later is recommended.

@node Tutorial,Reference,Installation,Contents
@anchor{tutorial doc}@anchor{7}@anchor{tutorial tut}@anchor{1}@anchor{tutorial tutorial}@anchor{8}
@section Tutorial


Turtles is a collection of tools for writing ERT tests that look at
the terminal showing an interactive Emacs instance from within that
instance. That is, you can setup buffer content and windows and check
how it looks like to a user running Emacs in a terminal.

Such ERT tests can run in batch mode as well an in interactive mode,
together with normal ERT tests.

To make that work, Turtles starts a secondary Emacs instance from
within a terminal buffer. Tests run in the secondary Emacs instance
and their result communicated to the primary Emacs instance. Whenever
needed, the primary instance grab the screen and provides the result,
that is, a terminal screen with colors and cursor position, to the
secondary instance.

To get started, install turtles (@ref{5,,Installation}), then create a new
test file with:

@example
;; -*- lexical-binding: t -*-

(require 'ert)
(require 'ert-x)
(require 'turtles)
@end example

If you checked out the source from
@indicateurl{https://github.com/szermatt/turtles}, you’ll find the tests shown
in this tutorial in the file test/turtles-example-test.el@footnote{https://github.com/szermatt/turtles/blob/master/test/turtles-examples-test.el}.

@menu
* Screen Grabbing with Hello World:: 
* Minibuffer with completing-read:: 
* Faces with Isearch:: 

@end menu

@node Screen Grabbing with Hello World,Minibuffer with completing-read,,Tutorial
@anchor{tutorial screen-grabbing-with-hello-world}@anchor{9}@anchor{tutorial tut-hello-world}@anchor{a}
@subsection Screen Grabbing with Hello World


Let’s write a test that creates a buffer, renders it and check the
result:

@example
(turtles-ert-deftest turtles-examples-hello-world ()
  ;; The body of turtles-ert-deftest runs inside a
  ;; secondary Emacs instance.

  (ert-with-test-buffer ()
    (insert "hello, ") ; Fill in the buffer
    (insert (propertize "the " 'invisible t))
    (insert "world!\n")

    (turtles-with-grab-buffer () ; Grab current buffer content
      (should (equal "hello, world!"
                     (buffer-string))))))
@end example

This call defines an ERT test called turtles-example-hello-world that
starts a secondary Emacs instances, then runs the rest of the test
within that instance. What Turtles calls instance is a separate Emacs
process that running a test defined by @code{turtles-ert-deftest} started
within a terminal window.

Running within a secondary instance is necessary because it is needed
by @code{(turtles-with-grab-buffer)}. (@ref{b,,Screen Grab}) This macro displays
its containing buffer in a window, grabs the content of that window
and puts than into an ERT test buffer.

The body of @code{turtles-with-grab-buffer} runs that grabbed buffer as
current buffer, then kills the buffer at the end, unless the test
failed, just like the body of @code{ert-with-test-buffer}. The content of
the buffer can be modified and checked with the usual tools.

In reality, the window that was grabbed didn’t have just two lines and
was larger than just the two words that appear here. What was really
grabbed contained spaces and newlines that @code{turtles-with-grabbed}
trimmed automatically to make it easier to test.

Try passing the option @code{:trim t} and re-running the test with
@cite{M-x ert-run-tests-interactively}:

@example
(turtles-with-grab-buffer (:trim t)
  (should (equal "hello, world!"
                 (buffer-string))))))
@end example

You’ll get something like the following in the @code{*ert*} buffer:

@example
F turtles-examples-hello-world
    Buffer: *Test buffer (turtles-examples-hello-world)*
    Buffer: *Test buffer (turtles-examples-hello-world): grab*
    (ert-test-failed
     ((should
       (equal "hello, world!"
              (buffer-string)))
      :form
      (equal "hello, world!"
             #("hello, world!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n" 0 13
               (face
                (...))
               13 35
               (face default)))
      :value nil :explanation
      (arrays-of-different-length 13 35 "hello, world!"
                                  #("hello, world!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n" 0 13
                                    (face
                                     (...))
                                    13 35
                                    (face default))
                                  first-mismatch-at 13)))
@end example

As you can see above, the window that was grabbed had a bit more than
20 lines. This corresponds to a single window within a 80x24 terminal,
the terminal dimensions of the default instance. (@ref{c,,Instance Management})

The ERT test buffers listed above:

@example
Buffer: *Test buffer (turtles-examples-hello-world)*
Buffer: *Test buffer (turtles-examples-hello-world): grab*
@end example

are part of that instance. If you click on either one of these, you’ll
be offered a choice of different ways of seeing these buffers. The
most convenient one, if you’re running in a windowing environment, is
to ask the instance to create a new frame to show the buffer.

@code{turtles-with-grab-buffer} doesn’t just grab the window content, but
actually the whole frame, then strips out everything that’s outside
the window. To better understand what this means, add the option
@code{:frame t}, as shown below, and run the tests again:

@example
(turtles-with-grab-buffer (:frame t)
  (should (equal "hello, world!"
                 (buffer-string))))))
@end example

Running the above with ERT will fail, and in the error message and the
buffers listed there, you’ll see the entire Emacs frame that was
grabbed, including the mode line and message area.

@code{turtles-with-grab-buffers} (@ref{b,,Screen Grab}) supports different keyword
arguments that let you choose a section of the screen to grab and
post-process it.

@node Minibuffer with completing-read,Faces with Isearch,Screen Grabbing with Hello World,Tutorial
@anchor{tutorial minibuffer-with-completing-read}@anchor{d}@anchor{tutorial tut-minibuffer}@anchor{e}
@subsection Minibuffer with completing-read


This second example illustrates the use of
@code{(turtles-with-minibuffer)} (@ref{f,,Minibuffer}) running
@code{completing-read}:

@example
(turtles-ert-deftest turtles-examples-test-completing-read ()
  (ert-with-test-buffer ()
    (let ((completing-read-function #'completing-read-default))
      (turtles-with-minibuffer
          (should
           (equal "Choice B"
                  (completing-read "Choose: " '("Choice A" "Choice B") nil t)))

        (turtles-with-grab-buffer (:name "initial prompt" :point "<>")
          (should (equal "Choose: <>" (buffer-string))))

        (execute-kbd-macro "Ch")
        (minibuffer-complete)
        (turtles-with-grab-buffer (:name "completion" :point "<>")
          (should (equal "Choose: Choice <>" (buffer-string))))

        (execute-kbd-macro "B")))))
@end example

@code{turtles-with-minibuffer} takes as argument two separate sections, shown below:

@example
(turtles-with-minibuffer
    READ
  BODY)
@end example

The READ section is a single sexp that calls a function that runs on
the minibuffer or within a recursive-edit. When this function returns,
@code{turtles-with-minibuffer} ends and returns the result of
evaluating READ.

The example above doesn’t care about what READ evaluates to, because
it checks the retrun value of @code{completing-read} directly within
that section.

The BODY section is a series of sexp that is executed interactively
`while the READ section runs'. This isn’t multi-threading, as
@code{turtles-with-minibuffer} waits for the READ sections to call
@code{recursive-edit}, usually indirectly through
@code{read-from-minibuffer}, and runs BODY within that interactive
session.

At the end of BODY, the minibuffer is closed, if needed, and control
returns to READ, which checks the result of running BODY.

Within that example BODY first checks the minibuffer content with:

@example
(turtles-with-grab-buffer (:name "initial prompt" :point "<>")
  (should (equal "Choose: <>" (buffer-string))))
@end example

The argument :point tells @code{turtles-with-grab-buffer} to
highlight the position of the cursor with “<>”. You can also check
that manually; it’s just convenient to see the content and the
position of the point in the same string.

This test interacts with @code{completing-read} by simulating the
user typing some text and pressing @code{TAB}.

The test could have directly called the command @code{TAB} is bound
to:

@example
(execute-kbd-macro "Ch")
(minibuffer-complete)
(turtles-with-grab-buffer (:name "completion" :point "<>")
  (should (equal "Choose: Choice <>" (buffer-string))))
@end example

Calling interactive commands in such a way in a test is usually
clearer than going through key bindings, and, in most cases, it works
well.

However, some commands that rely on the specific environment provided
by the command loop don’t like being called directly or even through
@code{execute-kbd-macro}. :keys and :command (@ref{f,,Minibuffer}) can help
in such tricky situations. Though it would be overkill here, you could
write:

@example
:keys "Ch"
:command #'minibuffer-complete
(turtles-with-grab-buffer (:name "completion" :point "<>")
  (should (equal "Choose: Choice <>" (buffer-string))))
@end example

@node Faces with Isearch,,Minibuffer with completing-read,Tutorial
@anchor{tutorial faces-with-isearch}@anchor{10}@anchor{tutorial tut-isearch}@anchor{11}
@subsection Faces with Isearch


This last example tests isearch. While not a minibuffer-based command,
isearch still works with @code{turtles-with-minibuffer}.

@example
(turtles-ert-deftest turtles-examples-test-isearch ()
  (ert-with-test-buffer ()
    (let ((testbuf (current-buffer)))
      (select-window (display-buffer testbuf))
      (delete-other-windows)

      (insert "Baa, baa, black sheep, have you any wool?")
      (goto-char (point-min))

      (turtles-with-minibuffer
          (isearch-forward)

        :keys "baa"
        (turtles-with-grab-buffer (:minibuffer t)
          (should (equal "I-search: baa" (buffer-string))))
        (turtles-with-grab-buffer (:buf testbuf :name "match 1" :faces '((isearch "[]")))
          (should (equal "[Baa], baa, black sheep, have you any wool?"
                         (buffer-string))))

        :keys "\C-s"
        (turtles-with-grab-buffer (:buf testbuf :name "match 2" :faces '((isearch "[]")))
          (should (equal "Baa, [baa], black sheep, have you any wool?"
                         (buffer-string))))

        (isearch-done))

      (turtles-with-grab-buffer (:name "final position" :point "<>")
        (should (equal "Baa, baa<>, black sheep, have you any wool?"
                       (buffer-string)))))))
@end example

The interesting bit here is:

@example
(turtles-with-grab-buffer (:buf testbuf :name "match 1" :faces '((isearch "[]")))
  (should (equal "[Baa], baa, black sheep, have you any wool?"
                 (buffer-string))))
@end example

The above checks which part of the buffer isearch highlighted. The
argument :faces tells @code{turtles-with-grab-buffer} to grab a small set
of faces and make them available in the buffer as the text property
‘face.

This example additionally provides “[]”, which tells
@code{turtles-with-grab-buffer} to mark portions of the buffer that have
such a face with brackets. This way, we don’t need to check text
properties in the test.

Faces aren’t really available when grabbing a terminal screen. To make
this work, Turtles uses colors to highlight the faces it’s interested
in, then recognize the faces it wants in the grabbed data from these
colors it has assigned.

@node Reference,Contributing,Tutorial,Contents
@anchor{reference doc}@anchor{12}@anchor{reference ref}@anchor{13}@anchor{reference reference}@anchor{14}
@section Reference


@menu
* ERT Integration:: 
* Screen Grab:: 
* Minibuffer:: 
* Instance Management:: 
* Visiting Instance Buffers:: 
* RPC (turtles-io): RPC turtles-io. 

@end menu

@node ERT Integration,Screen Grab,,Reference
@anchor{reference ert}@anchor{15}@anchor{reference ert-integration}@anchor{16}
@subsection ERT Integration


@geindex function; turtles-ert-deftest
@geindex function; turtles-upstream
@geindex function; turtles-this-instance

Turtles runs ERT tests is a secondary Emacs instance, which is started
and piloted by Turtles. This is what allows everything else in this
section to work.


@table @asis

@item (turtles-ert-deftest name (&key instance timeout) body) : macro

This macro define an ERT test with the given name that runs its
content inside of a secondary Emacs instance.

The ID of the instance to connect can be passed to the key
argument :instance. That ID defaults to @code{default}, an
instance with a 80x24 terminal. (@ref{c,,Instance Management})

A :timeout value, in seconds, can be passed to tell Turtles how
long to wait for an answer from the secondary instance. Increase
this value if you’re getting timeout errors.

The body of the macro is just like the body of a
@code{ert-deftest}, that is, it can contain:


@itemize -

@item 
an optional docstring

@item 
:tags and :expected-result key arguments

@item 
the test body possibly containing calls to (should), (should-not),
(skip-when) or (skip-unless), defined by @code{ert-deftest}.
@end itemize

@item (turtles-this-instance) : function

When run in a secondary Emacs instance, this function returns
the instance ID. It returns nil when not called from an
instance.

Calling this function provides a convenient way of knowing
whether the current code is running in the main Emacs process or
a secondary instance started by Turtles.

@item (turtles-upstream) : function

When called from a secondary Emacs instance, this function
returns the connection to the main Emacs process, a
@code{turtles-io-conn} struct. (@ref{17,,RPC (turtles-io)})

When called from the main Emacs process, this function returns
nil.
@end table

@node Screen Grab,Minibuffer,ERT Integration,Reference
@anchor{reference grab}@anchor{b}@anchor{reference screen-grab}@anchor{18}
@subsection Screen Grab


@geindex function; turtles-with-grab-buffer
@geindex function; turtles-to-string
@geindex function; turtles-mark-text-with-face
@geindex function; turtles-mark-text-with-faces
@geindex function; turtles-mark-point
@geindex function; turtles-trim-buffer
@geindex function; turtles-grab-frame
@geindex function; turtles-grab-buffer
@geindex function; turtles-grab-mode-line
@geindex function; turtles-grab-header-line
@geindex function; turtles-grab-window

Two macros are provided that fully control how the terminal frame is
grabbed and fully-processed: @code{turtles-with-grab-buffer} and
@code{turtles-to-string}, described below.

All functions that grab the terminal frame must be called from within
a secondary instance, that is, inside a @code{(turtles-ert-deftest)}.

When grabbing the terminal frame, the content of the current buffer is
replaced with a copy of the terminal data, with the point set at the
position of the cursor.

In that buffer, color and similar text attributes are available as a
@code{'face} text property. Starting with Emacs 29.1, the terminal
supports 24bit colors, but older Emacs versions must do with 16 or
even 8 colors. This usually doesn’t matter as it’s more convenient to
check for faces rather than colors, see the :faces key argument below.


@table @asis

@item (turtles-with-grab-buffer (&key …) &rest body) : macro

This macro creates an ERT test buffer, grabs the specified
portion of the frame, post-processes it, then evaluates BODY.

It then runs BODY with the ERT test buffer as current buffer.
BODY usually checks the buffer content with @code{should} and
@code{should-not}. At the end of BODY, the buffer is killed unless
the test failed.

Key arguments:

@quotation

`:name NAME' specifies the buffer name, “grab” by default. It is
forwarded to @code{ert-with-test-buffer}.
@end quotation

Key arguments that control what to grab:

@quotation

By default, the macro grabs the current buffer. If the buffer
is already shown in a window, it grabs that window, otherwise
it shows the buffer in a single window and grabs that.

:buf BUFFER-OR-NAME specifies another buffer to grab

:win WINDOW specifies a window to grab. The window doesn’t
have to be selected. However it will be selected when
grabbing.

:mode-line WIN-OR-BUF grabs the mode-line of the specified window or buffer.

:header-line WIN-OR-BUF grabs the header-line of the specified window or buffer.

:minibuffer t grabs the minibuffer window.

:margins t grabs the left and right margin. This only has an
effect when grabbing a buffer or a window.

:frame t grabs the whole frame.
@end quotation

Key arguments that control how to post-process what is grabbed:

@quotation

:point STR marks the position of the cursor with STR.

:faces FACE-LIST-OR-ALIST specifies a set of faces to grab. To
do that, Turtles assigns specific color to each face, grabs the
result, then detects faces in the gabbed data from colors. This
means that color data isn’t available when this option is used.

The face data can be recovered in the grabbed buffer in the text
property ‘face.

Additionally, it is possible to specify strings to use to mark
regions of the buffer with a specific face, to make it easier
to test using just @code{(equals ... (buffer-string))}.

FACE-LIST-OR-ALIST is a list of either:


@itemize -

@item 
the face to grab, a symbol

@item 
( face pair ) with pair being a string that can be split into
opening and closing strings, for example “()”, “[]” or even “<<>>”.

@item 
( face opening closing ) opening being
opening and closing strings, for example “face1:(” “)”
@end itemize

:trim nil tells the macro not to remove trailing whitespaces
and newlines.
@end quotation

@item (turtles-to-string) : macro

This macro works just like @code{turtle-with-grab-buffer} and
takes the same arguments, described above. The only difference
is that instead of opening an ERT test buffer, this function
returns the buffer content as a string.

So, instead of:

@example
(turtles-with-grab-buffer (...)
  ...
  (should (equal "..." (buffer-string))))
@end example

you’d write:

@example
(should (equal "..." (turtles-to-string ...)))
@end example

This is shorter, but doesn’t make the buffer available for
inspection when the test fails.
@end table

The two macros above form the frontend of the Turtles grabbing
functionality. Usually, that’s all you need. The macros calls the
functions below, which are then only useful if you choose to use
neither @code{turtles-with-grab-buffer} nor @code{turtles-to-string}.


@table @asis

@item (turtles-grab-frame &optional win grab-faces) : function

This puts the content of the terminal frame into the current
buffer and sets the point at the position where the cursor is.

WIN is a window that must be selected while grabbing.

GRAB-FACES is a list of face symbols to grab. See the
description of the :faces argument on
@code{turtles-with-grab-buffer}. (@ref{b,,Screen Grab})

@item (turtles-grab-window win &optional grab-faces margin) : function

This function puts the content of WIN into the current buffer
and puts the point at the position where the cursor is.

GRAB-FACES is a list of face symbols to grab. See the
description of the :faces argument on
@code{turtles-with-grab-buffer}. (@ref{b,,Screen Grab})

If MARGIN is non-nil, grab not only the body of the window, but
also the left and right margins.

@item (turtles-grab-buffer buf &optional grab-faces margins) : function

This function grabs BUF into the current buffer.

If BUF is shown on a window already, that window is the one
that’s grabbed. Otherwise, BUF is installed in the root window
of the frame before grabbing.

This function otherwise behaves as @code{turtles-grab-window}.
See that function for details.

@item (turtles-grab-mode-line win-or-buf &optional grab-faces) : function

This function grabs the mode line of the specified WIN-OR-BUF, a
window or buffer.

GRAB-FACES is a list of face symbols to grab. See the
description of the :faces argument on
@code{turtles-with-grab-buffer} (@ref{b,,Screen Grab})

@item (turtles-grab-header-line win-or-buf &optional grab-faces) : function

This function grabs the header line of the specified WIN-OR-BUF,
a window or buffer.

GRAB-FACES is a list of face symbols to grab. See the
description of the :faces argument on
@code{turtles-with-grab-buffer}. (@ref{b,,Screen Grab})

@item (turtles-mark-text-with-faces alist) : function

This function marks faces in the current buffer, as does the
:face argument of @code{turtles-with-grab-buffer}. It detects the
regions with a specific face in the current buffer and surrounds
them with an opening and a closing string, provided in the
alist.

ALIST is a list of, either:


@itemize -

@item 
@code{( face pair )} with pair being a string that can be split into
opening and closing strings, for example “()”, “[]” or even
“<<>>”.

@item 
@code{( face opening closing )} with separate opening and closing
strings, for example “face1:(” “)”
@end itemize

Note that for this function to work, the faces must have been
grabbed by one of the grab functions.

@item (turtles-mark-text-with-face face opening-or-pair &optional closing) : function

This is a shortcut for @code{turtles-mark-text-with-faces} for
marking a single face in the current buffer.

FACE is the symbol of the face to mark, OPENING-OR-PAIR is
either the opening string, or a string that can be split into
opening and closing, such as “()”, CLOSING is the closing
string.

@item (turtles-mark-point STR) : function

This function just calls (insert STR).

@item (turtles-trim-buffer) : function

This function deletes trailing whitespaces on all lines and
trailing newlines at the end of the current buffer.
@end table

@node Minibuffer,Instance Management,Screen Grab,Reference
@anchor{reference id1}@anchor{19}@anchor{reference minibuffer}@anchor{f}
@subsection Minibuffer


@geindex function; turtles-with-minibuffer


@table @asis

@item (turtles-with-minibuffer READ &rest BODY) : macro

This macro tests minibuffer or recursive-edit interactions.
It is meant to be called from within a secondary instance,
that is, inside of a @code{(turtles-ert-deftest)}.

The first sexp within that macro, the READ section, calls a
function that opens the minibuffer or a recursive-edit and waits
for user interactions. When this function returns, the macro ends
and returns whatever READ evaluates to.

The first sexp within that macro, the READ section, calls a
function that opens the minibuffer or a recursive-edit and waits
for user interactions. When this function returns, the macro ends
and returns whatever READ evaluates to.

The rest of the sexp within the macro, the BODY section, are
executed `while the READ section runs'. This isn’t
multi-threading, as @code{turtles-with-minibuffer} waits for the READ
sections to call @code{recursive-edit}, usually indirectly through
@code{read-from-minibuffer}, and then BODY within that interactive
session.

BODY is usually a mix of:


@itemize -

@item 
calls to @code{turtles-with-grab-buffer} to test the content of
the minibuffer or any other window.

@item 
keys passed to the minibuffer, with (execute-kbd-macro) or :keys (see
below for :keys).

@item 
commands that manipulate the minibuffer, called directly, using
(ert-simulate-command) or using :command (see below for :command).
@end itemize

At the end of BODY, the minibuffer is closed, if needed, and
control returns to READ, which checks the result of running BODY.

Special forms are available within BODY to simulate the user inputing
events using the command loop. In contrast to @code{execute-kbd-macro},
@code{ert-simulate-commands} and @code{ert-simulate-keys}, these
function use the real event loop, triggered by real, external events
(terminal keys). This isn’t as simulation.

You can’t use these special form except directly in BODY. The
following won’t work, for example: @code{(if cond :keys "abc")}


@table @asis

@item :keys keys

This expression provides KEYS as user input to the minibuffer.

KEYS is in the same format as passed to @code{kbd}.

Prefer @code{(execute-kbd-macro)}, when it works.

@item :events events

This expression provides a vector of events as the user input
to the minibuffer.

This is more general than the previous function as the events
can be any kind of UI events.

Prefer @code{(execute-kbd-macro)}, when it works.

@item :command command

This expression runs the given interactive command in the event
loop, triggered by a key stroke.

Prefer calling the command directly or through
@code{(ert-simulate-command)}, when it works.

@item :command-with-keybinding keybinding command

This expression works as above, but makes sure that the command
will find in @code{(this-command-keys)}, if it asks.
@end table

Usage examples: @ref{e,,Minibuffer with completing-read} and @ref{11,,Faces with Isearch}
@end table

@node Instance Management,Visiting Instance Buffers,Minibuffer,Reference
@anchor{reference instance-management}@anchor{1a}@anchor{reference instances}@anchor{c}
@subsection Instance Management


@geindex function; turtles-start-server
@geindex function; turtles-shutdown
@geindex function; turtles-restart
@geindex struct; turtles-instance
@geindex function; turtles-definstance
@geindex function; turtles-get-instance
@geindex variable; turtles-instance-alist
@geindex function; turtles-instance-shortdoc
@geindex function; turtles-instance-live-p
@geindex function; turtles-instance-eval
@geindex function; turtles-start-instance
@geindex function; turtles-stop-instance
@geindex function; turtles-read-instance
@geindex variable; turtles-live-instances

Turtles starts secondary Emacs instances from the main process. These
instances run the same version of Emacs with the same
@code{load-path}, in vanilla mode, without configuration.

The secondary Emacs instances are run within a hidden
@code{term-mode} buffer. Such buffers are called ”
`turtles-term-<instance-name>'” (note the space). You may switch to
that buffer to interact directly with the Emacs instance. To see
colors, rename it, as Emacs doesn’t bother processing ‘font-lock-face
in hidden buffers.

While secondary instances can be interacted with from that buffer, it
is awkward, as the two Emacs instances use the same keybindings. You
might be happier calling @code{turtles-new-frame-in-instance} (@ref{1b,,Visiting Instance Buffers})
if you’re running in a windowing environment, or otherwise
@code{turtles-instance-eval}. (@ref{c,,Instance Management})

The main Emacs process communicates with the secondary instances using
socket communication described in the next section @ref{17,,RPC (turtles-io)}. On
startup, the instances connect to the server, and, from then on,
communicate with the server through RPCs.

There can be multiple secondary instances, identified by a symbol,
their ID. Instances with different ids have different characteristics,
defined by @code{turtles-definstance}, described below. Turtles
defines one shared instance in a 80x25 terminal whose ID is ‘default.
This is the instance used by ERT tests unless specified otherwise.

Secondary instances can be started and stopped independently using
@code{turtles-start-instance} and @code{turtles-stop-instance}, and
communicated with using @code{turtles-instance-eval}.

During development, the versions of elisp libraries might get out of
sync between the main Emacs process and secondary instances. In such a
case, the simplest thing to do is to restart all live instances with
@code{turtles-restart}.


@table @asis

@item (turtles-start-server) : function

This function creates a @code{turtles-io-server} (@ref{17,,RPC (turtles-io)})
for instances to connect to. It doesn’t start any instances.

Calling this function is usually not necessary, as the server is
started automatically before starting the first instance.

@item (turtles-shutdown) : command

This function stops the current @code{turtles-io-server}
(@ref{17,,RPC (turtles-io)}) if it is running, as well as all instances connected
to it.

@item (turtles-restart) : command

This function shuts down the current server, then restarts any
live instances.

@item (cl-defstruct turtles-instance id doc conn width height forward setup term-buf): struct

This structure stores information about instances.

Use @code{turtles-definstance} to create and register instances
of this struct and call @code{turtles-get-instance} to find an
instance by its ID.

ID is the instance ID.

CONN is a @code{turtles-io-conn} (@ref{17,,RPC (turtles-io)}) to use to communicate
with the instance.

WIDTH, WEIGHT, FORWARD and SETUP are as passed to
@code{turtles-definstance}. See below for details.

TERM-BUF is the term-mode buffer within which the instance is
running, if it is running.

@item (turtles-definstance id (&key …) doc setup) : macro

Define a new instance with the given ID.

Turtles defines a shared instance with ID @code{default}. This is
the instance used by @ref{15,,turtle-ert-test} unless a
specific one is given. The default instance starts a 80x24
terminal with no setup.

Define your own custom instance whenever you need a different
screen size, setup or to forward the value of variables at
startup.

Make sure you set at least a short documentation in DOC. This
documentation is displayed in the prompt of
@code{turtles-start-instance}, @code{turtles-stop-instance} and
in the message issued when an instance is started.

The code in SETUP is executed before every ERT test. This is a
convenient place to put Emacs instance setup that you want to
remain constant across tests.

This macro takes the following key arguments:

:width WIDTH and :height HEIGHT to set the dimensions of the
terminal.

:forward SYMBOL-LIST provides a list of variable symbols whose
value should be copied to the instance at launch. This is useful
if you have variables whose value influence the tests that you
want to remain consistent between the main Emacs process and the
secondary instance.

Example:

@example
(turtles-definstance my-instance (:width 132 :height 43)
  "Emacs instance within a larger terminal.")
@end example

@item (turtles-get-instance inst-or-id) : function

This function returns a @code{turtles-instance}. Given an ID, it
returns the instance with that ID, or nil if it cannot be found.

Given a @code{turtles-instance}, it returns that instance. This
is useful to setup functions that take either an ID or an
instance. Such function just need to call
@code{turtles-get-instance} at startup.

@item (turtles-instance-alist) : variable

This alist maps @code{turtles-instance} IDs to their value.

This alist is normally only filled by @code{turtles-definstance}.

@item (turtles-instance-shortdoc inst-or-id) : function

Return a short description for the given @code{turtles-instance}
or ID.

The short description is built by taking the first line of the
documentation set in @code{turtles-definstance}.

@item (turtles-instance-live-p inst) : function

Return non-nil if the given instance is live.

@item (turtles-instance-eval inst-or-id expr &key timeout) : function

Evaluate EXPR on the given instance, identified by its ID or
@code{turtle-instance}.

This function waits for the evaluation to finish and returns the
result of that evaluation. If that evaluation is likely to take
time, set TIMEOUT to a value longer than the default 10s.

This function provides a convenient way to probe the internals of
an Emacs instance from the comfort of the main Emacs process.

For example, if you want to see what buffers are opened in the
secondary emacs instance, you can run @code{M-x eval-expression}
and evaluate @code{(turtles-instance-eval 'default
'(buffer-list))}.

@item (turtles-start-instance inst-or-id) : command

Start the given instance, unless it is already started.

If called interactively, ask for the instance to start among the
registered instances that aren’t live yet.

@item (turtles-stop-instance inst-or-id) : command

Stop the given instance, if it is running.

If called interactively, ask for the instance to stop among the
registered instances that are currently live.

@item (turtles-read-instance &optional prompt predicate) : function

Ask the use to choose an instance among those for which PREDICATE
evaluates to t.

PROMPT is displayed in the minibuffer.

PREDICATE takes a @code{turtles-instance} and should return
non-nil to accept that instance.

@item (turtles-live-instances) : function

Return the IDs of all live instances.
@end table

@node Visiting Instance Buffers,RPC turtles-io,Instance Management,Reference
@anchor{reference visit}@anchor{1b}@anchor{reference visiting-instance-buffers}@anchor{1c}
@subsection Visiting Instance Buffers


When a ERT tests is run inside a secondary Emacs instance, buffers
referenced in the test result should be looked up in the instance that
ran the test, and not the main Emacs process.

Such remote processes can be found in the test result or backtrace as
@code{'(turtles-buffer :name "..." :instance id)}. To visit such a
buffer, call @code{turtles-pop-to-buffer}

@geindex function; turtles-new-frame-in-instance
@geindex function; turtles-pop-to-buffer
@geindex function; turtles-pop-to-buffer-embedded
@geindex function; turtles-pop-to-buffer-copy
@geindex function; turtles-pop-to-buffer-new-frame
@geindex function; turtles-pop-to-buffer-actions
@geindex function; turtles-pop-to-buffer-action-history


@table @asis

@item (turtles-new-frame-in-instance inst-or-id) : command

When the main Emacs instance is run in a windowing environment,
you can ask the secondary Emacs instance to open a new frame and
inspect its state with this function.

When called interactively, it lets the use choose an instance
among those currently live.

@item (turtles-pop-to-buffer buffer) : function

This function displays buffers of the form @code{'(turtles-buffer :name "..." :instance id)}

To do so, it looks in @code{turtles-pop-to-buffer-actions} for
available actions and ask the user to choose one if there are more
than one. To skip this step, make sure that there’s only one
action on that list.

@item (turtles-pop-to-buffer-embedded …) : function

This function displays a buffer from another instance in the
terminal buffer of the main Emacs process. It is meant to be called
by @code{turtles-pop-buffer}.

@item (turtles-pop-to-buffer-copy …) : function

This function makes a copy of a buffer in another instance and
displays it in the main Emacs process. It is meant to be called by
@code{turtles-pop-buffer}.

@item (turtles-pop-to-buffer-new-frame …) : function

This function tells the secondary instance owning the buffer to
display to open a new frame showing that buffer. Only works if the
main Emacs process is running in a windowing environment. It is
meant to be called by @code{turtles-pop-buffer}.

@item (turtles-pop-to-buffer-actions) : variable

List of actions that @code{turtles-pop-to-buffer} should consider.
@end table

@node RPC turtles-io,,Visiting Instance Buffers,Reference
@anchor{reference rpc}@anchor{17}@anchor{reference rpc-turtles-io}@anchor{1d}
@subsection RPC (turtles-io)


@geindex function; turtles-io-server
@geindex struct; turtles-io-server
@geindex function; turtles-io-server-live-p
@geindex function; turtles-io-connect
@geindex struct; turtles-io-conn
@geindex function; turtles-io-conn-live-p
@geindex variable; turtles-io-unreadable-obj-props
@geindex function; turtles-io-handle-method
@geindex function; turtles-io-send-error
@geindex function; turtles-io-send-result
@geindex function; turtles-io-call-method
@geindex function; turtles-io-notify
@geindex function; turtles-io-call-method-async

turtles-io defines a very simple communication protocol for Emacs
instances to communicate with each other, inspired from JSON-RPC. It
is used to allow the main Emacs process and the secondary instances to
communicate.

The protocol is based on a socket-based communication between the main
Emacs process, the server, and the secondary Emacs instances, the
client.

Each side communicate with the other by sending messages
separated by @code{\n"""\n}. The messages are elisp expression of
the following form:


@itemize -

@item 
a method call:

@example
(:id id :method method-name :params params)
@end example

METHOD is the method name to call.

ID is used to identify the response when it comes. If no ID is
provided, the method is run, but no response is ever sent back. Such
a method call without ID is called a notification.

PARAMS is a lisp type defined by the method as its parameter. It
might be nil or missing.

@item 
a result:

@example
(:id id :result result)
@end example

This is a response to a previous method call. ID echoes the ID that
was passed to that call and RESULT is a lisp expression that the
method returns. It might be nil, but it cannot be missing.

@item 
an error:

@example
(:id id :error error)
@end example

This is a response to a previous method call. ID echoes the ID that
was passed to that call and RESULT should be a list expression of the same
type as those captured by @code{condition-case}. The CAR of that list is
an error symbol and the CDR its argument. Note that different processes
might not agree on the set of defined error symbols, so it is possible to
receive an error whose CAR is not an error symbol.
@end itemize

The elisp expressions are serialized using @code{prn1} and read back
using @code{read}. Many Emacs types cannot be serialized that way, so
Turtles defines placeholders for them:

@quotation


@itemize -

@item 
buffers: (turtles-buffer :name NAME) or (turtles-buffer :live
nil). Such placeholders can be opened from the main Emacs process
with @code{pop-to-buffer} (@ref{1b,,Visiting Instance Buffers})

@item 
window: (turtles-buffer :buffer BUFFER-NAME)

@item 
overlay: (turtles-overlay :from POS :to POS :buffer BUFFER-NAME)

@item 
marker: (turtles-marker :pos POS :buffer BUFFER-NAME)

@item 
frame: (turtles-frame :name TITLE)

@item 
anything else: (turtle-obj :type TYPE)
@end itemize
@end quotation

When running inside of a secondary Emacs instance, such placeholder
type are extended to include :instance ID to identify the source
instance.


@table @asis

@item (turtles-io-server socket &optional method-alist) : function

Create a new server, listening to the given SOCKET file.

METHOD-ALIST associates method ID to method handlers. A method
handles takes 4 arguments: conn, id, method, params and should
call one of @code{turtles-io-send-result} or
@code{turtles-io-send-error} once it is finished.

Return an instance of type @code{turtles-io-server}.

@item (turtles-io-server-live-p server) : function

Return non-nil if the given @code{turtles-io-server} instance is live.

@item (turtles-io-connect socket &optional method-alist) : function

Connect to a server running at the given SOCKET file.

METHOD-ALIST associates method ID to method handlers. A method
handles takes 4 arguments: conn, id, method, params and should
call one of @code{turtles-io-send-result} or
@code{turtles-io-send-error} once it is finished.

Return an instance of type @code{turtles-io-conn}.

@item turtles-io-conn : struct

This type represents a connection to some other Emacs instance.

@item (turtles-io-conn-live-p conn) : function

Retrun non-nil if the given @code{turtles-io-conn} is live.

@item (turtles-io-unreadable-obj-props) : variable

Properties to add to any placeholder generated for unreadable
(unserializable) objects such as buffers.

@item (turtles-io-handle-method conn method params (&key timeout)) : function

Call the given method on the connection with the given parameters.

This function waits for the result and returns it. If the call
returns an error, that error is sent as an signal.

@item (turtles-io-call-method-async conn method params handler) : function

Alternative to the above method that doesn’t wait for the result.
The result or the error is instead passed to the given handler,
which should take two arguments: result and error, only one of
which is ever non-nil.

@item (turtles-io-notify conn method &optional params) : function

Alternative to the above methods that doesn’t expect a result.

@item (turtles-io-send-error conn id error) : function

Send an error back to the called. Does nothing if the id is nil.

@item (turtles-io-send-result) : function

Send a result back to the called. Does nothing if the id is nil.
@end table

@node Contributing,,Reference,Contents
@anchor{contrib doc}@anchor{1e}@anchor{contrib contributing}@anchor{1f}
@section Contributing


@menu
* Reporting issues:: 
* Suggesting features:: 
* Asking questions:: 
* Code contributions:: 
* Documentation contributions:: 

@end menu

@node Reporting issues,Suggesting features,,Contributing
@anchor{contrib reporting}@anchor{20}@anchor{contrib reporting-issues}@anchor{21}
@subsection Reporting issues


At this time, the most useful thing you can do to help is and useful
bug reports to the Issue Tracker@footnote{https://github.com/szermatt/turtles/issues}

In your report, please discuss what you wanted to happen as well as
what happened. Also, please include enough information to reproduce
the issue.

Please include at least the version of turtles you’re using and the version of Emacs you’re running, taken, for example, from @code{M-x about-emacs}.

@node Suggesting features,Asking questions,Reporting issues,Contributing
@anchor{contrib suggesting-features}@anchor{22}
@subsection Suggesting features


Please add feature suggestions to the Issue Tracker@footnote{https://github.com/szermatt/turtles/issues} or start a discussion@footnote{https://github.com/szermatt/turtles/discussions}.

@node Asking questions,Code contributions,Suggesting features,Contributing
@anchor{contrib asking-questions}@anchor{23}
@subsection Asking questions


Start a discussion@footnote{https://github.com/szermatt/turtles/discussions} with your question.

@node Code contributions,Documentation contributions,Asking questions,Contributing
@anchor{contrib code-contributions}@anchor{24}
@subsection Code contributions


To contribute code to the project, open a Pull Request@footnote{https://github.com/szermatt/turtles/pulls} targeted to
the @code{dev} branch.

Before you do that, make sure the any new features is covered by tests
and that the tests pass.

To run the tests, install and setup eldev@footnote{https://github.com/emacs-eldev/eldev}, then run @code{eldev
test}.

Tests can also be run from inside of Emacs, using @cite{M-x ert-run-tests-interactively} but when you do so, be aware that there
might be unexpected interaction with your Emacs configurations. The
tests passing reliably when run using @code{eldev test} is what
matters.

Please also make sure your commit message follows Conventional Commits 1.0.0@footnote{https://www.conventionalcommits.org/en/v1.0.0/}, in
short, the commit message of new features should start with “feat: “,
fixes with “fix: “, refactorings with “refactor: ” and tests with
“test: “.

@node Documentation contributions,,Code contributions,Contributing
@anchor{contrib documentation-contributions}@anchor{25}@anchor{contrib eldev}@anchor{26}
@subsection Documentation contributions


You don’t need to be a developer to contribute! Contribution to the
documentation or code comments are very welcome. Please open a Pull Request@footnote{https://github.com/szermatt/turtles/pulls} targeting the @code{master} branch with your proposed
modifications. To follow Conventional Commits 1.0.0@footnote{https://www.conventionalcommits.org/en/v1.0.0/}, the
commit message should start with “docs: “

The documentation is written in reStructuredText. You’ll need to
install Sphinx@footnote{https://www.sphinx-doc.org} to build it:

@example
python3 -m venv venv
. venv/bin/activate # or activate.fish on fish
pip3 install -r docs/requirements.txt
@end example

Then run @code{eldev html} or @code{eldev build turtles.info}
to build the documentation.

@node Index,,Contents,Top
@unnumbered Index


@printindex ge


@c %**end of body
@bye
